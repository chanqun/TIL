# EAA

### 서문

아키텍처에 대한 핵심적인 개념은 이미 머릿속에 있다면 이 개념을 프레임워크로 적용하는 방법만 알아내면 된다.

#### 엔터프라이즈 애플리케이션은
- 막대한 규모의 복잡한 데이터를 표시, 관리, 저장
- 이러한 데이터를 이용한 비즈니스 프로세스를 지원하거나 자동화
  (예약 시스템, 금융 시스템, 공급망 시스템, 비즈니스 운영에 필수적인 다양한 시스템 - 임베디드 시스템, 제어 시스템, 통신, 데스크톱 생산성 소프트웨어와는 분명히 다른 고유한 과제와 해결책이 있음)

#### 주요 주제
- EAA 애플리케이션 계층화
- 도메인 논리 구성
- 웹 사용자 인터페이스 구성
- 인메모리 모듈과 관계형 데이터베이스 연결
- 상태 비저장 환경에서 세션 상태 처리
- 분산의 원리


### 들어가며

#### 아키텍처
시스템을 구성 요소로 나누는 최상위 수준의 분해, 번복하기 어려운 결정

#### 엔터프라이즈 애플리케이션
EAA는 대규모의 복잡한 데이터와 함께 논리적 추론으로는 설명되지 않는 비즈니스 규칙을 처리해야 하는 경우
- 지속적 데이터
- 막대한 양의 데이터
- 동시에 데이터 접근
- 사용자 인터페이스 화면
- 배치 프로세싱
- 다른 EAA와 통합해야 하는 경우가 많음


#### 엔터프라이즈 애플리케이션의 유형

- B2C 소매상 : 리소스를 아주 효율적으로 사용, 확장성, 다양한 브라우저로 이용할 웹 프레젠테이션이 필요
- 임대 계약 자동화 시스템 : 수백 명 정도가 사용하지만 비즈니스 논리 면에서 훨씬 복잡
- 소규모 기업을 위한 간단한 비용 추적 시스템 : 빠르게 POC 해야함

#### 성능에 대한 고려
필자는 실행 가능한 상태로 만들고, 성능을 측정한 후, 측정 데이터를 바탕으로 체계적인 최적화 절차를 이용
하지만 일부 아키텍처 결정은 나중에 최적화를 통해 해결하기 어려운 성능상의 영향을 미치는 경우가 있음

응답 시간, 응답성, 대기 시간, 처리량, 성능, 부하, 부하 민감도, 효율, 확장성

엔터프라이즈 시스템을 구축할 떄는 확장성에 중점을 두는 것이 유리


#### 패턴

모든 패턴은 우리의 환경에서 반복적으로 발생하는 문제를 설명하며, 이 문제에 대해 수백만 번이라도 반복해서 적용할 수 있지만
매번 다른 방법으로 적용할 수 있는 해결책의 핵심을 설명하는 것이다.

패턴이 무엇이고, 이 패턴으로 어떤 문제를 해결하고, 문제를 어떻게 해결하는지만 어느 정도 이해할 수 있으면 된다.
패턴을 이용하려면 먼저 패턴을 특정 환경에 적용하는 방법을 결정해야 한다.

#### 패턴의 구조
- 패턴의 이름
- 작동 원리
- 사용 시점
- 참고 자료

#### 패턴의 한계
패턴은 최종 목적지가 아닌 출발점이다.


## 1부 이야기

### 1장 계층화

#### 엔터프라이즈 애플리케이션에서 계층의 발전

예전에는 UI에서 데이터 검증이 있었음
-> 객체지향이 떴지만 유행하지 못했음 -> 웹이 등장하면서 계층화가 성장했음

#### 세 가지 주요 계층

- 프레젠테이션 : 사용자와 소프트웨어 간 상호작용을 처리
- 도메인 : 시스템의 핵심이 되는 논리 (입력된 데이터를 바탕으로 하는 계산, 프레젠테이션에서 받은 데이터의 유효성 검사, 프레젠테이션 명령을 기준으로 원본 논리를 결정)
- 데이터 원본 : 데이터베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와의 통신

#### 계층이 실행될 위치 선택

클라이언트, 서버..

### 2장 도메인 논리 구성

- 트랜잭션 스크립트
  - 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델, 트랜잭션의 경계를 설정하기 쉽다.
- 도메인 모델
  - 도메인 모델에 익숙해지면 복잡한 논리를 체계적으로 관리할 수 있는 다양한 기법을 활용할 수 있다.
  - 도메인 모델이 풍성해질수록 관계형 데이터베이스 매핑도 복잡해짐
- 테이블 모듈
  - 트랜잭션 스크립트와 도메인 모델의 중간적인 성격


#### 선택
도메인 논리가 얼마나 복잡하는냐에 따라 패턴 선택이 달라진다.

#### 서비스 계층
리치 서비스가 될 수 있고, 리치 도메인이 될 수 있음
서비스 객체에 비즈니스 논리를 절대 넣지 말라는 것이 아니라 고정적인 계층으로 만들 이유는 없다.


### 3장 관계형 데이터베이스 매핑
이 계층에서 가장 중요한 일은 데이터베이스와 상호작용하는 것

#### 아키텍처 패턴
도메인 논리가 데이터베이스와 상호작용하는 방법을 좌우하는 아키텍처 패턴으로 구성돼 있다.
SQL 접근을 도메인 논리와는 별도로 분리하고 개별 클래스에 배치하는 것이 좋다.
이러한 클래스는 테이블에 대한 게이트웨이가 된다. 애플리케이션의 ㅏㄴ머지 부분에서 SQL에 대해 알 필요가 없으며,
데이터베이스에 접근하는 모든 SQL은 쉽게 찾을 수 있다.

도메인 논리가 복잡해지면 점차 리치 도메인 모델에 가까워지고 활성 레코드의 간단한 접근법으로는 주체하지 못하게 됨
도메인 논리를 작은 클래스로 팩터링하기 시작하면 도메인 클래스와 테이블의 일대일 매칭이 깨지게 됨

따라서 테이블 간의 매핑을 간접 계층을 통해 완전히 처리해서 도메인 모델을 데이터베이스로부터 격리하는 것이 더 나은 방법
매퍼 <-> 도메인 모델 

객체지향 데이터베이스는 생산성 향상 하지만 관계형 데이터베이스는 오랫동안 사용 되어 왔음


#### 동작문제
다수의 객체를 메모리로 로드하고 수정할 때는 객체를 데이터베이스에 올바르게 기록하기 위해 수정한 객체를 모두 추적해야한다.
또한 객체를 읽고 이를 대상으로 작업할 때는 다른 프로세스가 이 객체를 변경하지 못하도록 읽기를 격리해야 한다. (동시성 문제)

작업 단위는 이러한 문제를 해결하는 데 꼭 필요한 패턴이다.
작업 단위는 데이터베이스에서 읽은 객체와 함께 이후 다양한 방법으로 수정한 객체를 추적하고 데이터베이스를 업데이트한다.
객체를 로드할 때 같은 객체를 두 번 로드하지 않게 해주는데 식별자 맵이 그러한 역할을 함

지연 로딩으로 객체 참조 대신 placeholder을 이용하기도 함

#### 데이터 읽기
- 1명씩 50번 읽는 것보다 200명 조회 후 50명만 추려내는 것이 좋다.
- 데이터베이스 접근을 줄이는 다른 방법은 조인을 사용해 쿼리 하나로 여러 테이블을 한 번에 가져오는 것

#### 구조적 매핑 패턴

###### 관계 매핑
객체와 관계형 데이터베이스가 연결을 처리하는 방법에는 차이가 있으며, 이 때문에 두 가지 문제가 발생
- 첫째는 참조 방법의 차이 객체는 참조를 저장하는 방법으로 연결을 처리
- 객체는 컬렉션을 사용해 단일 필드로 손쉽게 여러 참조를 처리할 수 있는 반면 관계형은 정규화를 지줭하기 위해모든 연관 링크가 단일 값을 가져야 한다.

컬렉션을 사용하는 것을 고려할 필요가 있음 - 컬렉션을 쿼리할 때마다 정렬 순서를 지정하는 것도 한 가지 방법이지만 성능이 크게 저하
-> 위상정렬 하는 것이 데이터베이스 문제를 해결해주는 방법이 될 수 있다.

###### 상속
데이터를 가져와서 상속하냐 테이블을 다 조인하게 만드냐가 차이가 있을 수 있음 (jpa 상속 테이블 전략 같은 것)

##### 매핑
- 스키마를 직접 선택할 수 있다.
- 기존의 스키마로 매핑해야 하며, 스키마를 변경할 수 없다.
- 기존의 스키마로 매핑해야 하지만 합의를 통해 스키마를 변경할 수 있다.


##### 메타데이터 사용
데이터베이스의 열이 객체의 필드에 매핑되는 구체적인 방법을 메타데이터 파일에 기록하는 것

##### 데이터베이스 연결
매번 컴파일되는 동적 SQL이 아니라 사전 컴파일되는 정적 SQL을 작성하는 데 투자하는 시간은 충분한 가치가 있다.

### 4장 웹 프레젠테이션


