# EAA

### 서문

아키텍처에 대한 핵심적인 개념은 이미 머릿속에 있다면 이 개념을 프레임워크로 적용하는 방법만 알아내면 된다.

#### 엔터프라이즈 애플리케이션은
- 막대한 규모의 복잡한 데이터를 표시, 관리, 저장
- 이러한 데이터를 이용한 비즈니스 프로세스를 지원하거나 자동화
  (예약 시스템, 금융 시스템, 공급망 시스템, 비즈니스 운영에 필수적인 다양한 시스템 - 임베디드 시스템, 제어 시스템, 통신, 데스크톱 생산성 소프트웨어와는 분명히 다른 고유한 과제와 해결책이 있음)

#### 주요 주제
- EAA 애플리케이션 계층화
- 도메인 논리 구성
- 웹 사용자 인터페이스 구성
- 인메모리 모듈과 관계형 데이터베이스 연결
- 상태 비저장 환경에서 세션 상태 처리
- 분산의 원리


### 들어가며

#### 아키텍처
시스템을 구성 요소로 나누는 최상위 수준의 분해, 번복하기 어려운 결정

#### 엔터프라이즈 애플리케이션
EAA는 대규모의 복잡한 데이터와 함께 논리적 추론으로는 설명되지 않는 비즈니스 규칙을 처리해야 하는 경우
- 지속적 데이터
- 막대한 양의 데이터
- 동시에 데이터 접근
- 사용자 인터페이스 화면
- 배치 프로세싱
- 다른 EAA와 통합해야 하는 경우가 많음


#### 엔터프라이즈 애플리케이션의 유형

- B2C 소매상 : 리소스를 아주 효율적으로 사용, 확장성, 다양한 브라우저로 이용할 웹 프레젠테이션이 필요
- 임대 계약 자동화 시스템 : 수백 명 정도가 사용하지만 비즈니스 논리 면에서 훨씬 복잡
- 소규모 기업을 위한 간단한 비용 추적 시스템 : 빠르게 POC 해야함

#### 성능에 대한 고려
필자는 실행 가능한 상태로 만들고, 성능을 측정한 후, 측정 데이터를 바탕으로 체계적인 최적화 절차를 이용
하지만 일부 아키텍처 결정은 나중에 최적화를 통해 해결하기 어려운 성능상의 영향을 미치는 경우가 있음

응답 시간, 응답성, 대기 시간, 처리량, 성능, 부하, 부하 민감도, 효율, 확장성

엔터프라이즈 시스템을 구축할 떄는 확장성에 중점을 두는 것이 유리


#### 패턴

모든 패턴은 우리의 환경에서 반복적으로 발생하는 문제를 설명하며, 이 문제에 대해 수백만 번이라도 반복해서 적용할 수 있지만
매번 다른 방법으로 적용할 수 있는 해결책의 핵심을 설명하는 것이다.

패턴이 무엇이고, 이 패턴으로 어떤 문제를 해결하고, 문제를 어떻게 해결하는지만 어느 정도 이해할 수 있으면 된다.
패턴을 이용하려면 먼저 패턴을 특정 환경에 적용하는 방법을 결정해야 한다.

#### 패턴의 구조
- 패턴의 이름
- 작동 원리
- 사용 시점
- 참고 자료

#### 패턴의 한계
패턴은 최종 목적지가 아닌 출발점이다.


## 1부 이야기

### 1장 계층화

#### 엔터프라이즈 애플리케이션에서 계층의 발전

예전에는 UI에서 데이터 검증이 있었음
-> 객체지향이 떴지만 유행하지 못했음 -> 웹이 등장하면서 계층화가 성장했음

#### 세 가지 주요 계층

- 프레젠테이션 : 사용자와 소프트웨어 간 상호작용을 처리
- 도메인 : 시스템의 핵심이 되는 논리 (입력된 데이터를 바탕으로 하는 계산, 프레젠테이션에서 받은 데이터의 유효성 검사, 프레젠테이션 명령을 기준으로 원본 논리를 결정)
- 데이터 원본 : 데이터베이스, 메시징 시스템, 트랜잭션 관리자 및 다른 패키지와의 통신

#### 계층이 실행될 위치 선택

클라이언트, 서버..

### 2장 도메인 논리 구성

- 트랜잭션 스크립트
  - 대부분의 개발자가 이해할 수 있는 간단한 절차적 모델, 트랜잭션의 경계를 설정하기 쉽다.
- 도메인 모델
  - 도메인 모델에 익숙해지면 복잡한 논리를 체계적으로 관리할 수 있는 다양한 기법을 활용할 수 있다.
  - 도메인 모델이 풍성해질수록 관계형 데이터베이스 매핑도 복잡해짐
- 테이블 모듈
  - 트랜잭션 스크립트와 도메인 모델의 중간적인 성격


#### 선택
도메인 논리가 얼마나 복잡하는냐에 따라 패턴 선택이 달라진다.

#### 서비스 계층
리치 서비스가 될 수 있고, 리치 도메인이 될 수 있음
서비스 객체에 비즈니스 논리를 절대 넣지 말라는 것이 아니라 고정적인 계층으로 만들 이유는 없다.


### 3장 관계형 데이터베이스 매핑
이 계층에서 가장 중요한 일은 데이터베이스와 상호작용하는 것

#### 아키텍처 패턴
도메인 논리가 데이터베이스와 상호작용하는 방법을 좌우하는 아키텍처 패턴으로 구성돼 있다.
SQL 접근을 도메인 논리와는 별도로 분리하고 개별 클래스에 배치하는 것이 좋다.
이러한 클래스는 테이블에 대한 게이트웨이가 된다. 애플리케이션의 나머지 부분에서 SQL에 대해 알 필요가 없으며,
데이터베이스에 접근하는 모든 SQL은 쉽게 찾을 수 있다.

도메인 논리가 복잡해지면 점차 리치 도메인 모델에 가까워지고 활성 레코드의 간단한 접근법으로는 주체하지 못하게 됨
도메인 논리를 작은 클래스로 팩터링하기 시작하면 도메인 클래스와 테이블의 일대일 매칭이 깨지게 됨

따라서 테이블 간의 매핑을 간접 계층을 통해 완전히 처리해서 도메인 모델을 데이터베이스로부터 격리하는 것이 더 나은 방법
매퍼 <-> 도메인 모델 

객체지향 데이터베이스는 생산성 향상 하지만 관계형 데이터베이스는 오랫동안 사용 되어 왔음


#### 동작문제
다수의 객체를 메모리로 로드하고 수정할 때는 객체를 데이터베이스에 올바르게 기록하기 위해 수정한 객체를 모두 추적해야한다.
또한 객체를 읽고 이를 대상으로 작업할 때는 다른 프로세스가 이 객체를 변경하지 못하도록 읽기를 격리해야 한다. (동시성 문제)

작업 단위는 이러한 문제를 해결하는 데 꼭 필요한 패턴이다.
작업 단위는 데이터베이스에서 읽은 객체와 함께 이후 다양한 방법으로 수정한 객체를 추적하고 데이터베이스를 업데이트한다.
객체를 로드할 때 같은 객체를 두 번 로드하지 않게 해주는데 식별자 맵이 그러한 역할을 함

지연 로딩으로 객체 참조 대신 placeholder을 이용하기도 함

#### 데이터 읽기
- 1명씩 50번 읽는 것보다 200명 조회 후 50명만 추려내는 것이 좋다.
- 데이터베이스 접근을 줄이는 다른 방법은 조인을 사용해 쿼리 하나로 여러 테이블을 한 번에 가져오는 것

#### 구조적 매핑 패턴

###### 관계 매핑
객체와 관계형 데이터베이스가 연결을 처리하는 방법에는 차이가 있으며, 이 때문에 두 가지 문제가 발생
- 첫째는 참조 방법의 차이 객체는 참조를 저장하는 방법으로 연결을 처리
- 객체는 컬렉션을 사용해 단일 필드로 손쉽게 여러 참조를 처리할 수 있는 반면 관계형은 정규화를 지줭하기 위해모든 연관 링크가 단일 값을 가져야 한다.

컬렉션을 사용하는 것을 고려할 필요가 있음 - 컬렉션을 쿼리할 때마다 정렬 순서를 지정하는 것도 한 가지 방법이지만 성능이 크게 저하
-> 위상정렬 하는 것이 데이터베이스 문제를 해결해주는 방법이 될 수 있다.

###### 상속
데이터를 가져와서 상속하냐 테이블을 다 조인하게 만드냐가 차이가 있을 수 있음 (jpa 상속 테이블 전략 같은 것)

##### 매핑
- 스키마를 직접 선택할 수 있다.
- 기존의 스키마로 매핑해야 하며, 스키마를 변경할 수 없다.
- 기존의 스키마로 매핑해야 하지만 합의를 통해 스키마를 변경할 수 있다.


##### 메타데이터 사용
데이터베이스의 열이 객체의 필드에 매핑되는 구체적인 방법을 메타데이터 파일에 기록하는 것

##### 데이터베이스 연결
매번 컴파일되는 동적 SQL이 아니라 사전 컴파일되는 정적 SQL을 작성하는 데 투자하는 시간은 충분한 가치가 있다.

### 4장 웹 프레젠테이션

모델 뷰 컨트롤러를 적용하는 첫 번쨰 이유 
- 웹 프레젠테이션으로부터 완전히 분리하기 위해서
- 처리를 별도의 트랜잭션 스크립트나 도메인 모델 객체에서 수행하면 테스트하기도 수월하다.

컨트롤러는 애플리케이션의 흐름을 처리하고 어떤 화면을 어떤 순서로 표시할지 결정하는 역할을 한다.
(프레젠테이션과 도메인 계층을 조정하는 별도의 계층)

#### 뷰 패턴
템플릿 뷰를 사용하면 페이지의 구조 안에 프레젠테이션을 작성하고 페이지에 표식을 삽입해 콘텐츠를 넣을 위치를 지정할 수 있다.
(ASP, JSP, PHP) 페이지 구조에서 프로그래밍 논리를 철저하게 배제하도록 노력해야 함

변환 뷰는 변환 스타일의 프로그램을 사용

1단계 뷰 - 화면당 페이지 하나
2단계 뷰 - 동일한 기본 레이아웃을 사용하고 논리적으로 변경

#### 입력 컨트롤러 패턴
페이지 컨트롤러
프런트 컨트롤러

### 5장 동시성
동시성 문제를 해결하기 어려운 이유 중 하나는 문제의 모든 원인을 미리 알기 어렵기 때문
(어떤 방법을 사용하든지 놓치는 부분이 있을 수 있고, 테스트하기도 어렵다)

트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다.
단일 데이터베이스 트랜잭션에 넣을 수 없는 것을 오프라인 동시성이라고 한다.

#### 동시성 문제
손실된 업데이트 한 명이 업데이트 한 코드에 다른 사람 업데이트가 누락되는 경우

일관성 없는 읽기는 올바르지만 한편으로 올바르지 않은 정보의 두 조각을 읽은 경우 발생

#### 실행 컨텍스트
외부 세계와 상호작용하는 관점에서 중요한 두 가지 컨텍스트로 요청과 세션이 있다.
요청은 소프트웨어가 작업하고 선택적으로 응답을 보내야 하는 외부 세계로부터의 단일 호출
요청의 처리는 대부분 서버 영역에서 수행되며 클라이언트는 응답을 기다리며 대기

세션은 클라이언트와 서버 간에 오랫동안 실행되는 상호작용. 세션은 한 요청만 포함할 수도 있지만, 이보다는 사용자가 하나의 일관된 논리적 흐름으로 생각하는 일련의 요청으로 이뤄지는 경우가 더 많다.

운영체제와 관련된 두 가지 중요한 용어로 프로세스와 스레드가 있다.
프로세스는 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행 컨텍스트
스레드는 한 프로세스 내에서 여러 스레드로 작동할 수 있게 구성된 소규모의 활성 에이전트

스레드는 일반적으로 메모리를 공유하기 떄문에 동시성 문제를 유발할 수 있다.
데이터베이스를 처리할 떄는 트랜잭션이라는 또 한가지 중요한 컨텍스가 있음

#### 격리와 불변성

동시성 문제는 프로세스나 스레드와 같은 활성 에이전트가 동시에 둘 이상 동일한 데이터에 접근할 때 발생한다.
격릴르 통해 데이터를 분리함으로써 하나의 활성 에이전트만 데이터에 접근할 수 있게 한다.
(한 사용자가 파일을 열면 다른 사용자는 이 파일을 열 수 없다.)

훌륭한 동시성 설계란 이러한 격리 환경을 만드는 방법을 찾고 이 환경 내에서 최대한 많은 프로그래밍 작업을 수행하는 것이다.

동시성 문제는 공유하는 데이터가 수정될 수 있을 때만 발생한다. 따라서 변경 불가능한 데이터를 인식할 수 있으면 동시성 충돌을 예방할 수 있다.


#### 낙관정 동시성 제어와 비관적 동시성 제어
격리할 수 없는 상황이라면 두 가지 방법으로 제어할 수 있따.

낙관적 잠금 - 두 사용자가 모두 자유롭게 파일을 복사하고 편집할 수 있지미나 늦게 수정한 사람이 변경 내용을 제출하려하면 충돌한다는 것을 감지
(충돌감지)

비관적 잠금 - 먼저 파일을 체크아웃하면 다른 사용자가 파일을 편집할 수 없게 된다.
(충돌예방) -> 충돌이 발생할 때 해결할 수 있음

##### 일관성 없는 읽기 예방
임시 읽기 제공

##### 교착 상태
시간 제한과 감지 기법은 모두 교착 상태가 발생하면 해결하는 기법

사용자가 잠금을 얻는 순서에 대한 규칙을 지정할 수 있다


#### 트랜잭션

##### ACID
- 원자성
- 일관성
- 격리성
- 지속성

##### 트랜잭션 리소스
처리량을 극대화하기 위해 최신 트랜잭션 시스템은 트랜잭션을 최대한 짧게 유지하도록 설계된다
다른 방법은 트랜잭션을 최대한 늦게 여는 것이다.
트랜잭션을 사용할 때는 어떤 리소스가 잠기는지 어느 정도 인식하고 있어야 한다.

##### 활동성을 위한 트랜잭션 격리성 저하
- serializable 
- repeatable read -> count에 대해서 달라짐 -> 팬텀
- unrepeatable read -> update에서도 달라짐
- read uncommitted -> 없어진 데이터를 읽을 수 있음 -> 더티리드

##### 비즈니스 트랜잭션과 시스템 트랜잭션

#### 오프라인 동시성 제어를 위한 패턴

#### 애플리케이션 서버 동시성
세션을 위해 객체를 생성할 수 있고 결과적으로 비교적 안전한 영역을 만들 수 있다고 해도 어떤 객체는 생성하는 비용이 정말 많이 들기 때문에 사용할 때 주의를 기울여야 한다. 
가장 일반 적인 예로 데이터베이스 연결이 있다.
이 문제를 해결하려면 이러한 객체를 명시적 풀에 넣고, 필요할 때 얻고, 사용이 끝나면 반환해야 한다. 
물론 이러한 작업은 동기화해야 한다.


### 6장 세션 상태
비즈니스 트랜잭션과 시스템 트랜잭션 간의 차이

#### 상태 비저장의 가치
객체의 핵심은 상태와 동작을 결합하는 것이다.
엔터프라이즈 애플리케이션의 상태 비저장은 이런 의미가 아님
이들이 말하는 상태 비저장 서버는 요청 간에 상태가 유지되지 않는 객체를 의미

상태 저장 서버 객체는 사용자가 웹 페이지를 보는 동안 대기하면서 모든 상태를 유지해야함
반면 상태 비저장 서버 객체는 다른 세션의 다른 요청을 처리할 수 있다.

장바구나 같은 겉은 상태가 저장되긴 해야함


#### 세션 상태
장바구니 안의 데이터는 특정 세션에만 해당

#### 세션 상태를 저장하는 방법
- 클라이언트 세션 상태 (URL 인코딩, 쿠키, 웹 양식, 리치 클라이언트 객체)
- 서버 세션 상태 
- 데이터베이스 세션 상태

어떤 것을 선택할 것이냐

인터넷 소매 사이트에서는 각 세션에서 사용하는 데이터의 양은 많지 않지만 유휴 사용자가 상당히 많을 수 있다. 따라서 데이터베이스 세션 상태가 성능 면에서 적절
임대 시스템에서는 각 요청마다 많은 양의 데이터가 데이터베이스로 오갈 수 있다. 따라서 서버 세션 상태를 선택하면 더 나은 성능


### 7장 분산 전략

#### 분산 객체의 매력
분산 객체의 여러 측면에 긍정적 영향을 주지만 일반적으로 성능에는 긍 정적 영향을 주지 않는다. 
설계자가 성능을 위해서라고 설명한 설계로 프로토타입 아키텍처를 구현하고 객체를 분산해도 실제로는 성능이 오히려 저하되며 시스템의 구축이나 배포도 훨씬 어려워진다.

#### 원격 및 로컬 인터페이스
가는 입자 인터페이스가 바람직한 이유는 다양한 방법으로 재정의 하고 결합해 향후에 설계를 확장할 수 있는 작은 조각으로 정의하는 객체지향의 일반적 규칙을 따르기 때문
프로세스 안에서 모든 클래스에 가는 입자 인터페이스를 사용할 수 있으므로 단순한 프로그래밍 모델을 바탕으로 관리 효율성을 높일 수 있다.

#### 분산이 필요한 상황
객체 분산은 도무지 방법이 없을 때 사용하는 최후의 수단

#### 분산 경계를 사용한 작업
그래도 여전히 단일 프로세스 안에서 가는 입자 객체를 사용해 설계할 수 있다. 
그 핵심은 내부 적으로는 가는 입자 객체를 사용하고 이에 대한 원격 인터페이스를 제공하는 굵은 입자 객체를 분산 경계에 배치하는 것
은 입자 인터페이스를 단순한 파사드로 유지함으로써 가는 입자 객체가 동일한 프로세스에서 실행되고 있다는 것을 아는 사람들에게 이 객체를 사용하도록 허용할 수 있다


#### 분산을 위한 인터페이스
지금까지 설명한 내용에서 필자는 동기식 RPC 기반 인터페이스를 사용한다고 가정 
그런데 사실 필자는 동기식 RPC 기반 인터페이스가 분산 시스템을 운영하는 최상의 방법이라고 생각
이보다는 근본적으로 비동기적인 메시지 기반 방식이 더 좋다고 생각
비동기 메시지 기반 방식이 웹 서 비스를 가장 잘 활용하는 방법


### 8장 종합

## 2부 패턴

### 9장 도메인 논리 패턴

#### 트랜잭션 스크립트

트랜잭션 스크립트(Transaction Script)는 이 모든 논리를 단일 프로시저로 구성하고 데이터 베이스를 직접 또는 씬 데이터베이스 래퍼를 통해 호출
스크립트의 인스턴스를 런타임에 객체로서 조작할 수 있다

#### 도메인 모델
비즈니스 논리는 경우에 따라 아주 복잡할 수 있다. 규칙과 논리는 매우 다양한 사례와 동작의 변형을 나타내며, 객체는 이러한 복잡성을 처리하기 위해 고안

#### 테이블 모듈
도메인 모델과의 가장 큰 차이점은 주문이 여러 개인 경우 도메인 모델은 주문의 수만큼 객체 를 사용하지만, 테이블 모듈은 모든 주문을 객체 하나가 처리한다

#### 서비스 계층
서비스 계층은 작업을 구현할 때 트랜잭션을 제어하며 응답을 조율하면서 애플리케이션의 비즈니스 논리를 캡슐화

### 10장 데이터 원본 아키텍처 패턴

#### 테이블 데이터 게이트웨이

