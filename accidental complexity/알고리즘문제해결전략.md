# 알고리즘 문제해결전략

## 1 문제 해결과 프로그래밍 대회

프로그래밍 대회 : 컴퓨터 과학 전반에 걸쳐 널리 쓰이는 각종 알고리즘과 자료 구조들을 이용해 주어진 문제들을 해결하고 구현하는 능력을 겨루는 대회
- 알고리즘 설계 기법과, 자료 구조를 이해하고 알고리즘 문제 해결 능력을 키울 수 있도록 구성

### 1.1 도입
프로그래밍은 문제 해결
좋은 프로그래머가 되기 위한 나은 방법은?

### 1.2 프로그래밍 대회

프로그래밍 대회에서 배울 수 있는 것들
1. 텍스트 파일을 읽고 출력함.
2. 명시적인 시간 제한과 메모리 제한이 있음
3. 정답과 오답의 여부가 명확함
4. 실행 시간과 메모리 사용량 관련 정보가 실시간으로 제공되기 때문에 작은 변경이 프로그램의 효율성에 미치는 영향을 체험해 볼 수 있음
5. 문제를 풀때마다 처음부터 다시 짜게하여 작은 부분에 집중하게 함
6. 여러 사람이 경쟁하는 환경에서 코드를 작성함

### 1.3 이 책을 읽는 방법
이 책의 구성 : 방법론, 코딩, 디버깅 주의사항,
필요한 배경 지식 : 수학, 기본적 자료구조
입문자를 위한 권장 사항 : 기초적인 주제 소화 후 다시 읽기

대회 참여, 준비할 것

## 2 문제 해결 개관

### 2.1 도입

### 2.2 문제 해결 과정
1. 문제를 이해한다.
2. 익숙한 용어로 재정의한다. (추상화)
3. 어떻게 풀지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 2.3 문제 해결 전략

- 직관과 체계적인 접근
- 체계적인 접근을 위한 질문들
  - 비슷한 문제 풀어봤나?
  - 단순한 방법에서 시작할 수 있을까?
  - 내가 문제를 푸는 과정을 수식화할 수 있을까?
  - 문제를 단순화할 수 없을까?
  - 그림으로 그려볼 수 있을까?
  - 수식으로 표현할 수 있을까?
  - 문제를 분해할 수 있을까?
  - 뒤에서부터 생각해서 문제를 풀 수 있을까?
  - 순서를 강제할 수 있을까?
  - 특정 형태의 답만을 고려할 수 있을까?

## 3 코딩과 디버깅에 관하여

### 3.1 도입 : 코딩의 중요성을 간과하지 말라
프로그래밍 대회에서 좋은 성적을 올리기 위한 비결은 당장 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것
간결하고 효율적인 프로그램을 작성하는 능력은 프로그래밍 대회에서 얻어 갈 수 있는 가장 큰 소득

### 3.2 좋은 코드를 짜기 위한 원칙
- 간결한 코드를 작성하기
- 적극적으로 코드 재사용하기 (모듈화)
- 표준 라이브러리 공부하기
- 항상 같은 형태로 프로그램을 작성하기
- 일관적이고 명료한 명명법 사용하기
- 모든 자료를 정규화해서 저장하기 (각도, UTC 시간, 분수)
- 코드와 데이터를 분리하기

### 3.3 자주 하는 실수
- 산술 오버플로
- 배열 범위 밖 원소에 접근
- 일관되지 않은 범위 표현 방식 사용하기
- Off-by-one
- 컴파일러가 잡아주지 못하는 상수 오타
- 스택 오버플로
- 다차원 배열 인덱스 순서 바꿔 쓰기
- 잘못된 비교 함수 작성
- 최소, 최대 예외 잘못 다루기
- 연산자 우선순위 잘못 쓰기 (&의 우선순위는 ==보다 낮음)
- 너무 느린 입출력 방식 선택
- 변수 초기화 문제

### 3.4 디버깅과 테스팅
디버깅
- 작은 입력에 대해 제대로 실행되나 확인
- 단정문을 씀
- 프로그램의 계산 중간 결과를 출력
테스트

### 3.5 변수 범위의 이해
- 산술 오버플로
- 너무 큰 결과
- 너무 큰 중간 값
- 너무 큰 무한대 값
- 오버플로 피해가기
- 자료형의 프로모션

### 3.6 실수 자료형의 이해
- 실수 연산의 어려움
- 실수와 근사 값
- IEEE 754 표준 (이진수를 실수로, 부동 소수점, 무한대, 비정규 수)
- 실수의 이진법 표기
- 실수 비교하기
  - 비교할 실수의 크기들에 비례한 오차 한도를 정함
  - 상대 오차를 이용
  - 대소 비교
  - 정확한 사칙연산
  - 코드의 수치적 안정성 파악하기
  - 경고
  - 실수 연산 아예 하지 않기

# 알고리즘 분석

알고리즘을 평가하는 두 가지의 큰 기준은 알고리즘의 시간과 공간

## 4 알고리즘의 시간 복잡도 분석

### 4.1 도입

반복문이 지배한다. 전체의 대소를 좌지우지하는 것을 지배한다고 표현

### 4.2 선형 시간 알고리즘
이동 평균 계산하기

### 4.3 선형 이하 시간 알고리즘
이진 탐색

### 4.4 지수 시간 알고리즘
다항 시간 알고리즘
지수 시간 알고리즘

### 4.5 시간 복잡도
점근적 시간 표기 : O 표기

### 4.6 수행 시간 어림짐작하기

### 4.7 계산 복잡도 클래스 : P, NP, NP-완비

NP문제, NP 난해 문제
NP문제란 답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제
마스터 정리 : 어떤 함수의 수행 시간이 특정 형태의 함수로 표현될 때 이 함수의 O표기법을 쉽게 계산할 수 있음

## 5 알고리즘의 정당성 증명

### 5.1 도입
알고리즘의 정당성 증명

### 5.2 수학적 귀납법과 반복문 불변식
- 단계 나누기, 첫 단계 증명, 귀납 증명
- 반복문 진입시 불변식 성립함을 보인다, 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 종료시 불변식이 성립하면 항상 우리가 정답을 구했다.
  - 단정문을 이용해 반복문 불변식 강제하기

### 5.3 귀류법
우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법

### 5.4 다른 기술들
- 비둘기집의 원리
- 동전 뒤집기
- 순환소수 찾기 (비둘기집의 원리를 이용 a%b의 결과는 언제나 [0,b-1]의 범위를 가짐)
- 구성적 증명 (답이 있음을 보여줌)
- 안정적 결혼 문제

# 알고리즘 설계 패러다임

알고리즘 설계 패러다임이란 주어진 문제를 해결하기 위해 알고리즘이 채택한 전략이나 관점을 말한다.

## 6 무식하게 풀기

### 6.1 도입
프로그래밍 대회에서 대부분의 사람들이 가장 많이 하는 실수는 쉬운 문제를 어렵게 푸는 것
brute-force 

### 6.2 재귀 호출과 완전 탐색
문제의 분할, 기저 사례의 선택, 구현, 시간 복잡도 분석

완전 탐색 레시피
1. 완전 탐색의 걸리는 시간은 답의 수에 정확히 비례
2. 조각이 하나밖에 남지 않는 경우 혹은 하나도 남지 않은 경우에는 답을 생성 기저 사례로 선택

시계 맞추기

## 7 분할 정복

- divide
- merge
- base case

행렬의 거듭제곱
A^m = A^(m/2) * A*(m/2)

두 수의 곱 (카라츠바 알고리즘)

```
int hugs(const string& members, const string& fans) {
  int N = members.size(), M = fans.size();
  vector<int> A(N), B(M);
  
  for (int i=0; i<N; i++) A[i] = (members[i] == 'M');
  for (int i=0; i<M; i++) B[M-i-1] = (fans[i] == 'M');
  
  vector<int> C = karatsuba(A,B);
  int allHugs = 0;
  for (int i =N-1; i<M;i++) {
    if(C[i] ==0) {
     allHugs++;
    }
  }
  
  return allHugs;
}

```

## 8 동적 계획법

동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에,
이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있다.

```
int bino(int n, int r) {
    if (r==0||n==r) return 1;
    return bino(n-1, r-1) + bino(n-1, r);
}

//

int cache[30][30];
int bino2(int n, int r) {
  if (r==0 || n==r) return 1;
  if (cache[n][r] != -1) {
    return cache[n][r];
  }
  
  return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```
메모이제이션은 참조적 투명 함수의 경우메만 적용할 수 있다.
입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없다.

int someObscureFunction(int a, int b);
한 번 계산하는데 굉장히 시간이 오래 걸리는 문제

(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)

## 9 동적 계획법 테크닉

