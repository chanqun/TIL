# 알고리즘 문제해결전략

## 1 문제 해결과 프로그래밍 대회

프로그래밍 대회 : 컴퓨터 과학 전반에 걸쳐 널리 쓰이는 각종 알고리즘과 자료 구조들을 이용해 주어진 문제들을 해결하고 구현하는 능력을 겨루는 대회
- 알고리즘 설계 기법과, 자료 구조를 이해하고 알고리즘 문제 해결 능력을 키울 수 있도록 구성

### 1.1 도입
프로그래밍은 문제 해결
좋은 프로그래머가 되기 위한 나은 방법은?

### 1.2 프로그래밍 대회

프로그래밍 대회에서 배울 수 있는 것들
1. 텍스트 파일을 읽고 출력함.
2. 명시적인 시간 제한과 메모리 제한이 있음
3. 정답과 오답의 여부가 명확함
4. 실행 시간과 메모리 사용량 관련 정보가 실시간으로 제공되기 때문에 작은 변경이 프로그램의 효율성에 미치는 영향을 체험해 볼 수 있음
5. 문제를 풀때마다 처음부터 다시 짜게하여 작은 부분에 집중하게 함
6. 여러 사람이 경쟁하는 환경에서 코드를 작성함

### 1.3 이 책을 읽는 방법
이 책의 구성 : 방법론, 코딩, 디버깅 주의사항,
필요한 배경 지식 : 수학, 기본적 자료구조
입문자를 위한 권장 사항 : 기초적인 주제 소화 후 다시 읽기

대회 참여, 준비할 것

## 2 문제 해결 개관

### 2.1 도입

### 2.2 문제 해결 과정
1. 문제를 이해한다.
2. 익숙한 용어로 재정의한다. (추상화)
3. 어떻게 풀지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 2.3 문제 해결 전략

- 직관과 체계적인 접근
- 체계적인 접근을 위한 질문들
  - 비슷한 문제 풀어봤나?
  - 단순한 방법에서 시작할 수 있을까?
  - 내가 문제를 푸는 과정을 수식화할 수 있을까?
  - 문제를 단순화할 수 없을까?
  - 그림으로 그려볼 수 있을까?
  - 수식으로 표현할 수 있을까?
  - 문제를 분해할 수 있을까?
  - 뒤에서부터 생각해서 문제를 풀 수 있을까?
  - 순서를 강제할 수 있을까?
  - 특정 형태의 답만을 고려할 수 있을까?

## 3 코딩과 디버깅에 관하여

### 3.1 도입 : 코딩의 중요성을 간과하지 말라
프로그래밍 대회에서 좋은 성적을 올리기 위한 비결은 당장 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것
간결하고 효율적인 프로그램을 작성하는 능력은 프로그래밍 대회에서 얻어 갈 수 있는 가장 큰 소득

### 3.2 좋은 코드를 짜기 위한 원칙
- 간결한 코드를 작성하기
- 적극적으로 코드 재사용하기 (모듈화)
- 표준 라이브러리 공부하기
- 항상 같은 형태로 프로그램을 작성하기
- 일관적이고 명료한 명명법 사용하기
- 모든 자료를 정규화해서 저장하기 (각도, UTC 시간, 분수)
- 코드와 데이터를 분리하기

### 3.3 자주 하는 실수
- 산술 오버플로
- 배열 범위 밖 원소에 접근
- 일관되지 않은 범위 표현 방식 사용하기
- Off-by-one
- 컴파일러가 잡아주지 못하는 상수 오타
- 스택 오버플로
- 다차원 배열 인덱스 순서 바꿔 쓰기
- 잘못된 비교 함수 작성
- 최소, 최대 예외 잘못 다루기
- 연산자 우선순위 잘못 쓰기 (&의 우선순위는 ==보다 낮음)
- 너무 느린 입출력 방식 선택
- 변수 초기화 문제

### 3.4 디버깅과 테스팅
디버깅
- 작은 입력에 대해 제대로 실행되나 확인
- 단정문을 씀
- 프로그램의 계산 중간 결과를 출력
테스트

### 3.5 변수 범위의 이해
- 산술 오버플로
- 너무 큰 결과
- 너무 큰 중간 값
- 너무 큰 무한대 값
- 오버플로 피해가기
- 자료형의 프로모션

### 3.6 실수 자료형의 이해
- 실수 연산의 어려움
- 실수와 근사 값
- IEEE 754 표준 (이진수를 실수로, 부동 소수점, 무한대, 비정규 수)
- 실수의 이진법 표기
- 실수 비교하기
  - 비교할 실수의 크기들에 비례한 오차 한도를 정함
  - 상대 오차를 이용
  - 대소 비교
  - 정확한 사칙연산
  - 코드의 수치적 안정성 파악하기
  - 경고
  - 실수 연산 아예 하지 않기

# 알고리즘 분석

알고리즘을 평가하는 두 가지의 큰 기준은 알고리즘의 시간과 공간

## 4 알고리즘의 시간 복잡도 분석

### 4.1 도입

반복문이 지배한다. 전체의 대소를 좌지우지하는 것을 지배한다고 표현

### 4.2 선형 시간 알고리즘
이동 평균 계산하기

### 4.3 선형 이하 시간 알고리즘
이진 탐색

### 4.4 지수 시간 알고리즘
다항 시간 알고리즘
지수 시간 알고리즘

### 4.5 시간 복잡도
점근적 시간 표기 : O 표기

### 4.6 수행 시간 어림짐작하기

### 4.7 계산 복잡도 클래스 : P, NP, NP-완비

NP문제, NP 난해 문제
NP문제란 답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제
마스터 정리 : 어떤 함수의 수행 시간이 특정 형태의 함수로 표현될 때 이 함수의 O표기법을 쉽게 계산할 수 있음

## 5 알고리즘의 정당성 증명

### 5.1 도입
알고리즘의 정당성 증명

### 5.2 수학적 귀납법과 반복문 불변식
- 단계 나누기, 첫 단계 증명, 귀납 증명
- 반복문 진입시 불변식 성립함을 보인다, 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 종료시 불변식이 성립하면 항상 우리가 정답을 구했다.
  - 단정문을 이용해 반복문 불변식 강제하기

### 5.3 귀류법
우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법

### 5.4 다른 기술들
- 비둘기집의 원리
- 동전 뒤집기
- 순환소수 찾기 (비둘기집의 원리를 이용 a%b의 결과는 언제나 [0,b-1]의 범위를 가짐)
- 구성적 증명 (답이 있음을 보여줌)
- 안정적 결혼 문제

# 알고리즘 설계 패러다임

알고리즘 설계 패러다임이란 주어진 문제를 해결하기 위해 알고리즘이 채택한 전략이나 관점을 말한다.

## 6 무식하게 풀기

### 6.1 도입
프로그래밍 대회에서 대부분의 사람들이 가장 많이 하는 실수는 쉬운 문제를 어렵게 푸는 것
brute-force 

### 6.2 재귀 호출과 완전 탐색
문제의 분할, 기저 사례의 선택, 구현, 시간 복잡도 분석

완전 탐색 레시피
1. 완전 탐색의 걸리는 시간은 답의 수에 정확히 비례
2. 조각이 하나밖에 남지 않는 경우 혹은 하나도 남지 않은 경우에는 답을 생성 기저 사례로 선택

시계 맞추기

## 7 분할 정복

- divide
- merge
- base case

행렬의 거듭제곱
A^m = A^(m/2) * A*(m/2)

두 수의 곱 (카라츠바 알고리즘)

```
int hugs(const string& members, const string& fans) {
  int N = members.size(), M = fans.size();
  vector<int> A(N), B(M);
  
  for (int i=0; i<N; i++) A[i] = (members[i] == 'M');
  for (int i=0; i<M; i++) B[M-i-1] = (fans[i] == 'M');
  
  vector<int> C = karatsuba(A,B);
  int allHugs = 0;
  for (int i =N-1; i<M;i++) {
    if(C[i] ==0) {
     allHugs++;
    }
  }
  
  return allHugs;
}

```

## 8 동적 계획법

동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에,
이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있다.

```
int bino(int n, int r) {
    if (r==0||n==r) return 1;
    return bino(n-1, r-1) + bino(n-1, r);
}

//

int cache[30][30];
int bino2(int n, int r) {
  if (r==0 || n==r) return 1;
  if (cache[n][r] != -1) {
    return cache[n][r];
  }
  
  return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```
메모이제이션은 참조적 투명 함수의 경우메만 적용할 수 있다.
입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없다.

int someObscureFunction(int a, int b);
한 번 계산하는데 굉장히 시간이 오래 걸리는 문제

(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)

## 9 동적 계획법 테크닉
예제 다시 읽어보기

## 10 탐욕법
탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.
탐욕법을 사용하는 이유는 동적 계획법에 필요한 메모리나 시간이 과도하게 클때

탐욕적 알고리즘 레시피
1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
2. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정, 이에 대한 직과능ㄹ 얻기 위해서는 예제 입력이나 그 외의 작은 입력을 몇 개 손으로 풀어보는 것이 효율적
3. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명
   - 탐욕적 선택 속성 : 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보인다.
   이 증명은 대개 우리가 선택한 답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어짐
   - 최적 부분 구조 : 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명, 다행히도 대개의 경우 이 속성이 성립하는지 아닌지는 자명하게 알 수 있음


## 11 조합 탐색

완전 탐색 알고리즘은 대개 답을 만드는 과정을 여러 개의 선택으로 나눈 뒤, 재귀 호출을 이용해 각각의 선택지를 채워가는 형태로 구현되곤 한다.
이때 부분 답과 완성된 답의 집합을 탐색 공간이라고 부른다. 

조합 탐색 최적화 기법
- 가지치기 : 탐색 과정에서 최적해로 연결될 가능성이 없는 부분들을 잘라낸다.
- 좋은 답을 빨리 찾아내는 기법들은 탐색의 순서를 바꾸거나, 탐색 시작 전에 탐욕법을 이용해 적당히 좋은 답을 우선 찾아낸다. 완전 탐색의 경우 답을 어떤 순서로 찾아내건 상관없지만, 가지치기와 함께 사용할 경우 더 좋은 답을 알고 있으면 좀더 일찍 탐색을 중단할 수 있기 떄문에 탐색의 효율이 좋아진다.

### 11.2 조합 탐색 기법들
- 최적해보다 나빠지면 그만두기
- 간단한 휴리스틱을 이용한 가지치기
- 메모이제이션하기


## 12 최적화 문제 결정 문제로 바꿔 풀기
최적화 문제의 반환 값은 대개 실수나 정수이므로 답의 경우의 수가 무한한 데 반해, 결정 문제는 두 가지 답만이 있을 수 있다.

```
bool decision(const Graph& g, double x) {
  return optimize(g) <= x;
}
```

유명한 알고리즘들

## 13 수치 해석

### 13.1 도입
수치 해석은 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 이들의 수치적 안정성, 오차의 범위 등을 연구하는 전산학의 한 분야로, 공학, 과학, 금융공학 등 다양한 범위에 널리 사용

### 13.2 이분법

#### 이분법의 정의
이분법은 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법이다.

### 절대 오차를 이용한 종료 판정
이분법에서 가장 중요한 부분은 바로 while 문의 종료 조건, while문을 많이 수행할수록 오차가 줄어들 테지만,
알고리즘을 영원히 수행할 수는 없는 노릇이니 우리는 정확도와 수행 속도 사이에서 적절히 타협하는 종료 조건을 선택하야 한다. 

### 상대 오차를 이용한 종료 판정

### 정해진 횟수만큼 반복하기
while를 for문 100번으로 으로 바꾸면
오차는 최대 = |lo - hi| / 2^101 (|lo - hi|가 10^20 미만 수이면 오차는 항상 10^-7 보다 작다.) 

## 14 정수론

### 14.1 도입
컴퓨토의 동작과 이산 수학은 떼려야 뗼 수 없는 관계이기 떄문에, 이와 연관된 정수론에 관련되 문제들도 프로그래밍 대회에 자주 등장한다.

### 14.2 소수

#### 소수 판별
sqrt까지, 홀수만 나눔
에라토스테네스의 체

#### 소인수 분해

### 14.5 유클리드 알고리즘
유클리드 알고리즘은 두수 p,q (p>q)의 공약수의 집합은 p-q와 q의 공약수 집합과 같다
gcd(6,15) = gcd(9,6) = gcd(3,6) = gcd (3,3) = gcd(0,3)
0과 3의 최대공약수는 3이므로 6과 15의 최대공약수도 3이다.

```java
int gcd(int p, int q) {
    if (p < q) {
        swap(p, q);
    }
    if (q==0) {
        return p;
    }
    
    return gcd(p-q, q);
}
```


### 14.8 모듈러 연산
디오판틴 방정식을 통해서 모듈러 나눗셈 문제를 풀 수 있음.

#### 14.9 더 읽을거리

확장 유클리드 알고리즘
중국인 나머지 정리
루카스의 정리

### 15 계산 기하

#### 15.1 도입
점, 선, 다가형과 원 등 각종 기하학적 도형을 다루는 알고리즘을 계산 기하 알고리즘이라고 한다.
계산 기하는 3D 그래픽이나 캐드, 로보틱스 등 다양한 분야의 기반이 되기 때문에 전산학에서 중요한 역할을 차지한다.

#### 15.2 계산 기하의 도구들
- 벡터의 구현 struct vector
- 점과 직선, 선분의 표현
- 벡터의 내적과 외적

#### 15.3 교차와 거리, 면적
면적, 내외부 판별

## 기초 자료구조

모든 자료 구조는 이 두 가지 목적을 이루기 위해 고안 된 것들이다. 추상화와 최적화

- 현실 세계의 추상화 : 추상화란 현실 세계에 존재하는 개념이나 구조를 간결화해 컴퓨터 프로그램에 사용되는 자료 구조로 표현하는 과정을 가리킨다
- 최적화 : 자료 구조를 설계하는 다른 목적인 최적화는 프로그램의 동작 속도를 빠르게하기 위한 것이다.

### 16 비트마스크

정수의 이진수 표현을 자료 구조로 쓰는 기법을 비트마스크라고 부른다.

장점
- 더 빠른 수행 시간 : 비트마스크 연산은 O(1)에 구현되는 것이 많다.
- 더 간결한 코드 : 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있다.
- 더 작은 메모리 사용량
- 연관 배열을 배열로 대체 : int[]를 사용해 같은 정보를 나타낼 수 있다.

- 비트 연산자
  - AND & , OR | , XOR ^, NOT ~, 왼쪽 시프트 a<<b, 오른쪽 시프트 a>>b
  - 비트 연산자는 ==, != 보다 우선순위가 낮음
  - 1은 32비트 64비트랑 비교할떄 조심

#### 16.2 비트마스크를 이용한 집합의 구현

- 피자집 예제 : 토핑 넣기 / 넣지 않기
- 공집합과 꽉 찬 집합 구하기 : int fullPizza = (1<<20) - 1;
- 원소 추가 : toppings |= (1 << p);
- 원소의 포함 여부 : if (toppings & (1 << p)) cout << "pepperoni is in" << endl;
- 원소의 삭제 : toppings &= ~(1 << p);
- 원소의 토글 : toppings ^= (1 << p);
- 두 집합에 대해 연산하기
  - int added = (a | b);
  - int intersection = (a & b);
  - int removed = (a & ~b);
  - int toggled = (a ^ b);
- 집합의 크기 구하기
```
int bitCount(int x) {
  if (x == 0) return 0;
  return x % 2 + bitCount(x / 2);
}
```
- 최소 원소 찾기 : int firstTopping = (toppings & -toppings);
- 최소 원소 지우기 : toppings &= (toppings - 1);
- 모든 부분 집합 순회하기
```
for(int subset = pizza; subset; subset = ((subset-1) & pizza))
```

#### 16.3 비트마스크의 응용 예제

- 지수 시간 동적 계획법
  - 에라토스테네스의 체 unsigned char sieve[(MAX_N)+7 / 8];
  - 우선 순위 큐 O(1)


### 17 부분 합

#### 17.1 도입
- 부분합 구하기
psum[b] - psum[a-1]
반복문을 통해 구간 합을 구하기 위해 최대 O(N)의 시간이 걸리므로, 구간 함을 두 번 이상 구할 때는 대부분의 경우 부분 합을 사용하는 것이 좋다.
- 부분 합으로 분산 계산하기
- 2차원으로 확장


### 18 선형 자료 구조

#### 18.1 도입
동적 배열과 연결 리스트, 이 두 자료 구조는 배열과 연결 리스트

#### 18.2 동적 배열
배열의 특징 : 원소들은 메모리의 연속된 위치에 저장, 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있음
동적 배열 추가 특징 : resize() 연산 가능, 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append()연산을 지원 상수 시간 걸림
#### 18.3 연결 리스트


### 19 큐와 스택, 데크
- 연결 리스트를 통한 구현
- 동적 배열을 이용한 구현

### 20 문자열
#### 20.1 도입
KMP(Knuth-Morris-Pratt) 알고리즘, 접미사 배열
KMP 알고리즘(Knuth-Morris-Pratt Algorithm)은 문자열 검색 알고리즘으로, 검색하려는 문자열(Pattern)과 검색 대상 문자열(Text)을 비교하는 효율적인 방법을 제공
패턴의 접두사와 접미사의 일치를 활용해 불필요한 비교를 줄이는 것이 특징


```
public class KMPAlgorithm {

    // KMP 알고리즘을 사용하여 패턴을 검색하는 메서드
    public static void KMPSearch(String pat, String txt) {
        int M = pat.length();
        int N = txt.length();

        // 패턴을 위한 LPS(Longest Prefix Suffix) 배열을 생성
        int[] lps = new int[M];
        int j = 0; // 패턴의 인덱스

        // LPS 배열을 계산
        computeLPSArray(pat, M, lps);

        int i = 0; // 텍스트의 인덱스
        while (i < N) {
            if (pat.charAt(j) == txt.charAt(i)) {
                j++;
                i++;
            }

            if (j == M) {
                System.out.println("패턴이 " + (i - j) + " 인덱스에서 발견되었습니다.");
                j = lps[j - 1];
            }

            // 불일치가 발생한 경우
            else if (i < N && pat.charAt(j) != txt.charAt(i)) {
                // j가 0이 아니면 LPS 배열을 참고
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
    }

    // 패턴에 대한 LPS 배열을 계산하는 메서드
    public static void computeLPSArray(String pat, int M, int[] lps) {
        int len = 0; // 가장 긴 접두사와 접미사가 일치하는 부분의 길이
        int i = 1;
        lps[0] = 0; // 첫 번째 인덱스의 LPS 값은 항상 0

        // 패턴을 순회하면서 LPS 배열을 계산
        while (i < M) {
            if (pat.charAt(i) == pat.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
    }

    // 메인 메서드: 실행 예시
    public static void main(String[] args) {
        String txt = "ABABDABACDABABCABAB";
        String pat = "ABABCABAB";
        KMPSearch(pat, txt);
    }
}
```


## 5 트리



