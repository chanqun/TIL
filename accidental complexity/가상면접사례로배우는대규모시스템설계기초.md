# 가상면접사례로배우는대규모시스템설계기초

### 4장 처리율 제한 장치의 설계
사례
- 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
- 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다.
- 같은 디바이스로는 주당 5회 이상 리워드를 요청할 수 없다.
(트위터는 3시간 300개의 트윗, 구글 독스는 분당 300회의 read 요청만 허용)

- DoS 공격을 방어
- 서버 과부하를 막음
- thrid-party 사용료 지불 시 중요 

#### 1단계 문제 이해 및 설계 범위 확정

처리율 제한 장치를 구현하는 데는 여러 가지 알고리즘을 사용할 수 있음 
> 클라이언트측 or 서버측
> ip or id 기준 api 제한? > 다양한 제어 규칙 유연하게
> 시스템 규모는 > 대규모
> 분산 환경에서 동작해야 
> 독립된 서비스인지 코드에 포함될 수 있는지
> 제한 장치에 걸러지면 알려줘야함

요구사항
- 설정된 처리율을 초과하는 요청은 정화하게 제한
- 낮은 응답시간
- 가능한 한 적은 메모리 사용
- 분산형 처리율 제한 : 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야한다.
- 예외 처리 : 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여주어야한다.
- 높은 결함 감내성 : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주면 안 된다.

#### 2단계 개략적 설계안 제시 및 동의 구하기
클라이언트 측은 위변조가 쉬움, 서버측에 두거나, 미들웨어로 통제

클라우드 MSA인 경우 처리율 제한 장치는 API 게이트웨이라 불리는 컴포넌트에 구현된다.
(처리율 제한, SSL 종단, 사용자 인증, ip white list 관리함)

처리율 제한 알고리즘
- token bucket : 토큰을 주기적으로 주고 버킷이 차면 토큰 버리고 토큰이 있어야 요청 가능 (사용자별 token bucket 을 지급)
  - 장점 : 구현이 쉬움, 메모리 효율적, 짧은 시간 트래픽 처리 가능
  - 단점 : 이 알고리즘은 버킷 크기와 토큰 공급률 두 개 인자를 가지고 있는데 적절하게 튜닝하는 것이 어렵다
- leaky bucket : token bucket 과 유사하지만 처리율이 고정되어 있음, fifo 구조 큐가 가득 차 있으면 버림 
  - 장점 : 큐의 크기가 제한 메모리 사용량 효율적, 안정적 출력 
  - 단점 : 단시간에 많은 트래픽이 몰리면 오래된 요청이 쌓이고 최신 요청은 버려짐, 인자 설정이 어려움 (버킷 크기, 처리율)
- fixed window counter : 타임라인을 고정된 간격의 window로 나누고 counter를 붙임
  - 장점 : 메모리 효율이 좋음, 이해하기 쉬움, 윈도가 닫히는 시점 초기화하는 방식은 특정한 트래픽 패턴을 처리하기 쉬움
  - 단점 : 윈도 경계 부근에서 처리 한도보다 많은 양의 요청을 처리하게 됨
- sliding window log : 타임스탬프 데이터를 레디스의 sorted set 캐시에 보관, 새 요청이 들어오면 만료된 타임스템프는 제거, 새 요청 로그에 추가, 허용치보다 같거나 작으면 요청을 시스템에 전달
  - 장점 : 어느 순간의 윈도를 보더라도 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.
  - 단점 : 다량의 메모리를 사용한다.
- sliding window counter : 현재 1분간의 요청 수 + 직전 1분간의 요청수 * 이동 윈도와 직전 1분이 겹치는 비율
  - 장점 : 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응, 메모리 효율이 좋다.
  - 단점 : 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 계산하는 것 (cloudflare 실험 결과 시스템에 맞지 않는 경우는 0.003%정도)

#### 3단계 상세 설계
- 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
- 처리가 제한된 요청들은 어떻게 처리되는가?

처리율 제한 규칙은 디스크에 보관, 요청을 버리거나 메시지 큐에 저장하거나

##### 분산 처리시
여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장해야함
- race condition (lua script, sorted set)
- synchronization (sticky session, 중앙 집중형 데이터 저장소 사용)

##### 성능 최적화
##### 모니터링

#### 4단계 마무리
- hard or soft 처리율 제한
- 다양한 계층에서의 처리율 제한
- 처리율 제한을 회피하는 방법, 클라이언트를 어떻게 설꼐하는 것이 최선
  - 캐시 사용, 짧은 시간 메시지 많이 보내지 않도록, 에러를 우아하게 복구, 재시도 로직을 구현할 떄는 충분한 back-off


### 5장 안정 해시 설계
해시 링 + 가상 노드

- 서버가 추가되거나 삭제될 떄 재배치되는 키의 수가 최소화
- 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉬움
- 핫스팟 키 문제를 줄인다

### 6장 키-값 저장소 설계
정족수 합의 프로토콜
R=1, W=N : 빠른 읽기 연산에 최적화
W=1, R=N : 빠른 쓰기 연산에 최적화
W + R > N : 강한 일관성이 보장
W + R < N : 강한 일관성이 보장되지 않음

대규모 데이터 저장 : 안정 해시를 사용해 서버들에 부하 분산
읽기 연산에 대한 높은 가용성 보장 : 데이터를 여러 데이터센터에 다중화
쓰기 연산에 대한 높은 가용성 보장 : 버저닝 및 벡터 시계를 사용한 충돌 해소
데이터 파티션 : 안정 해시
점진적 규모 확장성 : 안정 해시
다양성 : 안정 해시
조절 가능한 데이터 일관성 : 정족수 합의
일시적 장애 처리 : 느슨한 정족수 프로토콜과 단서 후 임시 위탁
영구적 장애 처리 : 머클 트리
데이터 센터 장애 대응 : 여러 데이터 센터에 걸친 데이터 다중화

### 7장 분산 시스템을 위한 유일 ID 생성기 설계




