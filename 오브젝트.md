## 오브젝트 - OBJECTS

[1. 객체, 설계](#1-객체-설계)   
[2. 객체지향 프로그래밍](#2-객체지향-프로그래밍)

### 1. 객체, 설계

로버트 L. 글래스 실무가 먼저다  
소프트웨어 설계와 소프트웨어 유지보수에서 실무가 이론보다 앞서고 있음

> 소프트웨어 모듈의 세 가지 목적
> 1. 실행 중에 제대로 동작
> 2. 변경을 위해 존재
> 3. 코드를 읽는 사람과 의사소통
> - 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다. - 마틴 아저씨

1장의 Theater 예제는 관람객의 돈을 극장이 빼가고 티켓박스의 돈을 가져간다. 
우리의 상식과는 다르게 동작하고 있음, 변경에도 취약함
--> 객체 사이의 의존성의 문제 (최소한의 의존성만 유지해야함) 결합도가 높으면 좋지 않다.

> 관람객과 판매원을 자율적인 존재로 만들자!


물리적으로 객체 내부의 세부적인 사항을 감추는 것은 캡슐화(encapsulation)라 한다.    
-> 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.

!! 캡슐화와 응집도
핵심 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것

> 각 객체는 자신을 스스로 책임

계속 코드를 개선 ---> 코드를 개선하다보니 TicketSeller가 TicketOffice 의 구현이 아닌 인터페이스에만 의존하게 되었다
하지만 변경 전에는 존재하지 않았던 audience와의 의존성이 생겼다.
- audience에 대한 결합도와 ticketOffice의 자율성을 모두 만족시키는 방법이 잘 떠오르지 않음
    트레이드오프의 시점이 왔다.
  
- 설계는 균형의 에술
> 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.  
> 레베카 워프스브록은 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인환라고 부른다.

### 2. 객체지향 프로그래밍

DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름을 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인
getDiscountAmount 메서드에 위임한다. 실제로는 DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메소드가 실행될 것이다.
이처럼 부모 클래스에 기본적인 알고리즘의 흐르을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라고 한다.

책 예제의 코드 상에서는 Movie는 DiscountPolicy에 의존한다. 그러나 실행 시점에는 Movie의 인스턴스는 AmountDiscountPolicy나 PercentDiscountPolicy의
인스턴스에 의존하게 된다.
-> 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있따.
한 가지 간과해서 안 되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록
코드는 더 유연하고 확장 가능해진다. 이와 같은 의존성의 양면성은 설계가 트레이드 오프의 산물이라는 사실을 보여준다.

> 상속과 인터페이스  
> 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
> 
> 다형성    
> Movie는 DiscountPolicy의 인스턴스에게 calculateDiscountAmount 메시지를 전송하고 실행되는 메서드는 연결된 객체의 클래스가 무엇인가에 따라 달라진다.
> 이를 다형성이라고한다.

- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 부른다.

- 구현 상속은 순수하게 코드를 재사용하기 위한 것, 인터페이스 상속은 다형적인 협력을 위해 부모 클래스의 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것

NoneDiscountPolicy를 만들어서 Movie, DiscountPolicy는 수정하지 않고 애플리케이션의 기능을 확장하였다.

-> 할인 금액이 0원이라는 사실을 효과적으로 전달할 수 있지만 NoneDiscountPolicy를 추가한 것은 과하다고 생각할 수 있다.
여기서 이야기하는 사실은 구현과 관련되 모든 것들이 트레이드오프의 대상이 될 수 있다는 사실이다. 
> 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 비록 아주 사솟한 결정이라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.
> 고민하고 트레이드오프해야한다.

- 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 인스턴스 변수로 연결하는 방법을 사용하면 실행 시점에 할인 정책을 간단하게 변경할 수 있음

