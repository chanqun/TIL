# 이펙티브 자바

자바는 단일 상속 방식의 객체 지향 언어이고, 메서드 안의 코드는 명령 형(문장 지향) 방식으로 작성

## 1장 들어가며
자바가 지원하는 타입: interface, class, array, primitive

## 2장 객체 생성과 파괴

- 체를 만들어야 할 때와 만들지 말 아야 할 때를 구분하는 법
- 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법
- 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업

### 생성자 대신 정적 팩터리 메서드
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

장점
1. 이름을 가질 수 있다. - 어떤 역할을 할지 헷갈릴 일이 없음
2. 호출될 때마다 인스턴스를 생성하지는 않아도 됨다. - 인스턴스 통제
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

단점
1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

### 생성자에 매개변수가 많다면 빌더를 고려

### private 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴을 만드는 방식은 보통 둘 중 하나. 두 방식 모두 생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로
public static 멤버를 하나 마련

### 인스턴스화를 막으려거든 Private 생성자를 사용하라

private으로 막으면 상속을 불가능하게 하는 효과가 있다.

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

인스턴스를 생성할 떄 생성자에 필요한 자원을 넘겨주는 방식

클래스가 내부적으로 하나 이상의 자원에 의존하고, 
그 자원이 클래스 동작에 영향을 준 다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
이 자원들을 클래스가 직접 만들게 해서도 안 된다. 
대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 
의존 객체 주입이라 하는 이 기법은 클 래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

### 불필요한 객체 생성을 피하라

### 다 쓴 객체 참조를 해제하라
객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체...)를 회수해가지 못한다.
- 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메 모리 누수에 주의해야 한다.
- 캐시 역시 메모리 누수를 일으키는 주범이다.

### finalizer와 cleaner 사용을 피하라
finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다.
상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner 에 의존해서는 안 된다.

Autoclosable 을 구현해줌
cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자

### try-finally 보다는 try-with-resources 를 사용
코드는 더 짧고 분명해지고 예외 정보도 훨씬 유용하다.

## 3장 모든 객체의 공통 메서드

### equals는 일반 규약을 지켜 재정의하라
equals를 재정의해야 할 때

객체 식별성(object identity; 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 
상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.


equals 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.
- 반사성(reflexivity):null이아닌모든참조값x에대해,x.equals(x)는true다.
- 대칭성(symmetry): null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
- 추이성(transitivity): null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
- 일관성(consistency):null이아닌모든참조값x,y에대해,x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- null-아님: null이 아닌 모든 참조값 x에 대해,x.equals(null)은 false다.

### equals를 재정의하려거든 hashCode도 재정의하라

- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되어야함
- equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다.
- equals가 두 객체를 다르다고 판단했더라고, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.

### toString을 항상 재정의하라
실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.

### clone 재정의는 주의해서 진행하라
로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 되며, 새로운 클래스도 이를 구현해서는 안 된다.
final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다.
기본 원칙은 ‘복제 기능은 생성자와 팩터리를 이용하는 게 최고’라는 것이다.

### Comparable을 구현할지 고려하라

- Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y. compareTo(x))여야 한다(따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질 때에 한해 예외를 던져야 한다).
- Comparable을 구현한 클래스는 추이성을 보장해야 한다. 즉, (x.compareTo(y) > 0 && y.compareTo(z) > 0)이면x.compareTo(z) > 0이다.
- Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x. compareTo(z)) == sgn(y.compareTo(z))다.
- 이번 권고가 필수는 아니지만 꼭 지키는 게 좋다. (x.compareTo(y) == 0) == (x. equals(y))여야 한다. Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 다음과 같이 명시하면 적당할 것이다.


## 4장 클래스와 인터페이스

### 클래스와 멤버의 접근 권한을 최소화하라
프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개 되는 일이 없도록 해야 한다. 
public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. public static final 필드가 참조하는 객체가 불 변인지 확인하라.

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

### 변경 가능성을 최소화하라

### 상속보다는 컴포지션을 사용하라
상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스와 하위 클래스 가 순수한 is-a 관계일 때만 써야 한다.
is-a 관계일 때도 안심할 수만은 없는 게, 하위 클 래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다 면 여전히 문제가 될 수 있다.
상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

### 상속을 고려해 설계하고 문서화하라 그러지 않았다면 상속을 금지하라
상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
상속용으로 설계하지 않은 클래스는 상속을 금지해야한다.

### 추상 클래스보다는 인터페이스를 우선하라.
인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다.
일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.

### 인터페이스는 구현하는 쪽을 생각해 설계하라

### 인터페이스는 타입을 정의하는 용도로만 사용하라
상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.
인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하 지 말자.

### 태그 달린 클래스보다는 클래스 계층구조를 활용하라
태그 달린 클래스는 클래스 계층구조를 어설프게 흉내 낸 아류일 뿐이다.

### 멤버 클래스는 되도록 static으로 만들라
멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.

### 톱레벨 클래스는 한 파일에 하나만 담으라
소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자.

## 5장 제네릭

### raw type은 사용하지 말라
런타임에 예외가 일어날 수 있으니 사용하면 안 된다. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다. 빠르게 훑어보자면, Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고,
Set<?>는 모 종의 타입 객체만 저장할 수 있는 와일드카드 타입이다.
그리고 이들의 로 타입인 Set은 제네릭 타입 시스템에 속하지 않는다. Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.

### 비검사 경고를 제거하라
할 수 있는 한 모든 비검사 경고를 제거

### 배열보다는 리스트를 사용하라
배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면,
제네릭은 불공변이고 타입 정보가 소거된다. 그 결과 배열은 런타임에는 타입 안전하지 만 컴파일타임에는 그렇지 않다. 
제네릭은 반대다. 그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방 법을 적용해보자.

### 이왕이면 제네릭 타입으로 만들라
클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 
그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라. 
그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다. 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자. 
기존 클라이언트에는 아무 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다

### 이왕이면 제네릭 메서드로 만들라

### 한정된 와일드카드를 사용해 API 유연성을 높이라

펙스(PECS): producer-extends, consumer-super

### 제네릭과 가변인수를 함꼐 쓸 떄는 신중하라