# 이펙티브 자바

자바는 단일 상속 방식의 객체 지향 언어이고, 메서드 안의 코드는 명령 형(문장 지향) 방식으로 작성

## 1장 들어가며
자바가 지원하는 타입: interface, class, array, primitive

## 2장 객체 생성과 파괴

- 체를 만들어야 할 때와 만들지 말 아야 할 때를 구분하는 법
- 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법
- 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업

### 생성자 대신 정적 팩터리 메서드
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

장점
1. 이름을 가질 수 있다. - 어떤 역할을 할지 헷갈릴 일이 없음
2. 호출될 때마다 인스턴스를 생성하지는 않아도 됨다. - 인스턴스 통제
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

단점
1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

### 생성자에 매개변수가 많다면 빌더를 고려

### private 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴을 만드는 방식은 보통 둘 중 하나. 두 방식 모두 생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로
public static 멤버를 하나 마련

### 인스턴스화를 막으려거든 Private 생성자를 사용하라

private으로 막으면 상속을 불가능하게 하는 효과가 있다.

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

인스턴스를 생성할 떄 생성자에 필요한 자원을 넘겨주는 방식

클래스가 내부적으로 하나 이상의 자원에 의존하고, 
그 자원이 클래스 동작에 영향을 준 다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
이 자원들을 클래스가 직접 만들게 해서도 안 된다. 
대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 
의존 객체 주입이라 하는 이 기법은 클 래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

### 불필요한 객체 생성을 피하라

### 다 쓴 객체 참조를 해제하라
객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체...)를 회수해가지 못한다.
- 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메 모리 누수에 주의해야 한다.
- 캐시 역시 메모리 누수를 일으키는 주범이다.

### finalizer와 cleaner 사용을 피하라
finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다.
상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner 에 의존해서는 안 된다.

Autoclosable 을 구현해줌
cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자

### try-finally 보다는 try-with-resources 를 사용
코드는 더 짧고 분명해지고 예외 정보도 훨씬 유용하다.

## 3장 모든 객체의 공통 메서드

### equals는 일반 규약을 지켜 재정의하라
equals를 재정의해야 할 때

객체 식별성(object identity; 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 
상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.


equals 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.
- 반사성(reflexivity):null이아닌모든참조값x에대해,x.equals(x)는true다.
- 대칭성(symmetry): null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
- 추이성(transitivity): null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
- 일관성(consistency):null이아닌모든참조값x,y에대해,x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- null-아님: null이 아닌 모든 참조값 x에 대해,x.equals(null)은 false다.

### equals를 재정의하려거든 hashCode도 재정의하라

- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되어야함
- equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다.
- equals가 두 객체를 다르다고 판단했더라고, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.

### toString을 항상 재정의하라
실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.

### clone 재정의는 주의해서 진행하라
로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 되며, 새로운 클래스도 이를 구현해서는 안 된다.
final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다.
기본 원칙은 ‘복제 기능은 생성자와 팩터리를 이용하는 게 최고’라는 것이다.

### Comparable을 구현할지 고려하라

- Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y. compareTo(x))여야 한다(따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질 때에 한해 예외를 던져야 한다).
- Comparable을 구현한 클래스는 추이성을 보장해야 한다. 즉, (x.compareTo(y) > 0 && y.compareTo(z) > 0)이면x.compareTo(z) > 0이다.
- Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x. compareTo(z)) == sgn(y.compareTo(z))다.
- 이번 권고가 필수는 아니지만 꼭 지키는 게 좋다. (x.compareTo(y) == 0) == (x. equals(y))여야 한다. Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 다음과 같이 명시하면 적당할 것이다.


## 4장 클래스와 인터페이스

### 클래스와 멤버의 접근 권한을 최소화하라
프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개 되는 일이 없도록 해야 한다. 
public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. public static final 필드가 참조하는 객체가 불 변인지 확인하라.

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

### 변경 가능성을 최소화하라

### 상속보다는 컴포지션을 사용하라
상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스와 하위 클래스 가 순수한 is-a 관계일 때만 써야 한다.
is-a 관계일 때도 안심할 수만은 없는 게, 하위 클 래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다 면 여전히 문제가 될 수 있다.
상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

### 상속을 고려해 설계하고 문서화하라 그러지 않았다면 상속을 금지하라
상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
상속용으로 설계하지 않은 클래스는 상속을 금지해야한다.

### 추상 클래스보다는 인터페이스를 우선하라.
인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다.
일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.

### 인터페이스는 구현하는 쪽을 생각해 설계하라

### 인터페이스는 타입을 정의하는 용도로만 사용하라
상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.
인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하 지 말자.

### 태그 달린 클래스보다는 클래스 계층구조를 활용하라
태그 달린 클래스는 클래스 계층구조를 어설프게 흉내 낸 아류일 뿐이다.

### 멤버 클래스는 되도록 static으로 만들라
멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.

### 톱레벨 클래스는 한 파일에 하나만 담으라
소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자.

## 5장 제네릭

### raw type은 사용하지 말라
런타임에 예외가 일어날 수 있으니 사용하면 안 된다. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다. 빠르게 훑어보자면, Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고,
Set<?>는 모 종의 타입 객체만 저장할 수 있는 와일드카드 타입이다.
그리고 이들의 로 타입인 Set은 제네릭 타입 시스템에 속하지 않는다. Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.

### 비검사 경고를 제거하라
할 수 있는 한 모든 비검사 경고를 제거

### 배열보다는 리스트를 사용하라
배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면,
제네릭은 불공변이고 타입 정보가 소거된다. 그 결과 배열은 런타임에는 타입 안전하지 만 컴파일타임에는 그렇지 않다. 
제네릭은 반대다. 그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방 법을 적용해보자.

### 이왕이면 제네릭 타입으로 만들라
클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 
그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라. 
그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다. 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자. 
기존 클라이언트에는 아무 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다

### 이왕이면 제네릭 메서드로 만들라

### 한정된 와일드카드를 사용해 API 유연성을 높이라

펙스(PECS): producer-extends, consumer-super

### 제네릭과 가변인수를 함꼐 쓸 때는 신중하라
varargs 매개변수를 사용하고자 한다면, 
먼저 그 메서드가 타입 안전한지 확인한 다음 @SafeVarargs 애너테이션을 달아 사용하는 데 불편함이 없게끔 하자.

### 타입 안전 이종 컨테이너를 고려하라

## 6장 열거 타입과 애너테이션

### int 상수 대신 열거 타입을 사용하라
### ordinal 메서드 대신 인스턴스 필드를 사용하라
### 비트 필드 대신 EnumSet을 사용하라
### ordinal 인덱싱 대신 EnumMap을 사용하라

### 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다.

### 명명 패턴보다 애너테이션을 사용하라
### @Override 애너테이션을 일관되게 사용하라
### 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라


## 7장 람다와 스트림

### 익명 클래스보다는 람다를 사용하라
익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라. 

### 람다보다는 메서드 참조를 사용하라

정적 : Integer::parseInt, str -> Integer.parseInt(str)   
한정적 (인스턴스) : Instant.now()::isAfter, Instant then = Instant.now(); t -> then.isAfter(t)
비한정적 (인스턴스) 클래스 생성자 : String::toLowerCase, str -> str.toLowerCase()  
배열 생성자 : TreeMap<K,V>::new, () -> new TreeMap<K,V>()
핵심 정리 : int[]::new, len -> new int[len]


메서드 참조는 람다의 간단명료한 대안이 될 수 있다. 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.


### 표준 함수형 인터페이스를 사용하라
입력값과 반환값에 함수형 인터페이스 타입을 활용하라. 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다. 
단, 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수 있음

### 스트림을 주의해서 사용하라
스트림(stream)은 데이터 원소의 유한 혹은 무한 시퀀스(sequence)를 뜻함
두 번째인 스트림 파이프라인(stream pipeline)은 이 원소들로 수행하 는 연산 단계를 표현하는 개념


스트림 쓰기 좋은 곳
- 스트림 파이프라인은 지연 평가(lazy evaluation) 됨
- 원소들의 시퀀스를 일관되게 변환한다.
- 원소들의 시퀀스를 필터링한다.
- 원소들의 시퀀스를 하나의 연산을 사용해 결합한다(더하기, 연결하기, 최솟값 구하기 등).
- 원소들의 시퀀스를 컬렉션에 모은다(아마도 공통된 속성을 기준으로 묶어가며).
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

### 스트림에서는 부작용 없는(side effect) 함수를 사용하라
스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다. 
스트림뿐 아니 라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다. 
종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야 한다. 계산 자체에는 이용하지 말자.
스트림을 올바로 사용하려면 수집기를 잘 알아둬야 한다. 
가장 중요한 수집기 팩터리는 toList, toSet, toMap, groupingBy, joining이다.


### 반환 타입으로는 스트림보다 컬렉션이 낫다

컬렉션을 반환하는 게 불가능하면 스트 림과 Iterable 중 더 자연스러운 것을 반환하라.
만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 자바가 수정된다면,
그때는 안심하고 스트림을 반환하면 될 것 이다(스트림 처리와 반복 모두에 사용할 수 있음)

### 스트림 병렬화는 주의해서 적용하라
데이터 소스가 Stream.iterate거나 중간 연 산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap 의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수 에 비례하는 성능 향상을 만끽할 수 있다.

## 8장 메서드

### 매개변수가 유효한지 검사하라
오류는 가능한 한 빨리 (발생한 곳에서) 잡아야 한다
java.util.Objects.requireNonNull

### 적시에 방어적 복사본을 만들어라
클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.

```java
public Period(Date start, Date end) { 
    this.start = new Date(start.getTime()); 
    this.end = new Date(end.getTime());
    
    if (this.start.compareTo(this.end) > 0) {
        throw new IllegalArgumentException(this.start + " after " + this.end);
    }
}
```
클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요 소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.

### 메서드 시그니처를 신중히 설계하라

메서드 이름을 신중히 짓자.
편의 메서드를 너무 많이 만들지 말자.
클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
매개변수 목록은 짧게 유지하자.(같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.)
boolean보다는 원소 2개짜리 열거 타입이 낫다

### 다중정의는 신중히 사용하라

이처럼 직관과 어긋나는 이유는 재정의한 메서드는 동적으로 선택되고, 
다중정의한 메서드는 정적으로 선택되기 때문이다.
안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
다중정의하는 대신 메서드 이름을 다르게 지어주는 길 도 항상 열려 있으니 말이다.

### 가변인수는 신중히 사용하라
```java
public void foo() { }
public void foo(int a1) { }
public void foo(int a1, int a2) { }
public void foo(int a1, int a2, int a3) { }
public void foo(int a1, int a2, int a3, int... rest) { }
```
3개까지는 미리 만들고 그 이후에는 배열을 만듬

인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다. 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문 제까지 고려하자.

### null이 아닌, 빈 컬렉션이나 배열을 반환하라

### 옵셔널 반환은 신중히 하라
값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면 옵셔널을 반환해야 할 상황일 수 있다. 
하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있다. 그리고 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

### 공개된 API 요소에는 항상 문서화 주석을 작성하라

## 9장 일반적인 프로그래밍 원칙

### 지역변수의 범위를 최소화하라
지역변수의 범위를 줄이는 가장 강력한 기법은 역시 ‘가장 처음 쓰일 때 선언하기’다.
메서드를 작게 유지하고 한 가 지 기능에 집중하는 것이다.

### 전통적인 for 문보다는 for-each문을 사용하라

사용할 수 없는 경우
- 파괴적인 필터링
- 변형
- 병렬 반복

### 라이브러리를 익히고 사용하라
표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머 들의 경험을 활용할 수 있다.

### 정확한 답이 필요하다면 float와 double은 피하라
금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.

### 박싱된 기본 타입보다는 기본 타입을 사용하라
오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주 지는 않는다.
언박싱 과정에서 NullPointerException을 던질 수 있다.

### 다른 타입이 적절하다면 문자열 사용을 피하라
문 자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.

### 문자열 연결은 느리니 주의하라

### 객체는 인터페이스를 사용해 참조하라
적합한 인터페이스 가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.

### 리플렉션보다는 인터페이스를 사용하라
- 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
- 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
- 성능이 떨어진다.

### 네이티브 메서드는 신중히 사용하라
성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하 지 않는다.

### 최적화는 신중히 하라
- 빠른 프로그램보다는 좋은 프로 그램을 작성하라.
- 성능을 제한하는 설계를 피하라.
- API를 설계할 때 성능에 주는 영향을 고려하라.
- 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다.(각각의 최적화 시도 전후로 성능을 측정하라)

### 일반적으로 통용되는 명명 규칙을 따르라

패키지와 모듈 : org.junit.jupiter.api, com.google.common.collect 
클래스와 인터페이스 : Stream, FutureTask, LinkedHashMap, HttpClient
메서드와 필드 : remove, groupingBy, getCrc
상수 필드 : MIN_VALUE, NEGATIVE_INFINITY
지역변수 : i, denom, houseNum
타입 매개변수 : T,E,K,V,X,R,U,V,T1,T2

## 10장 예외

### 예외는 진짜 예외 상황에만 사용하라






