# JVM 밑바닥까지 파헤치기

## 1부 자바와 친해지기

### 1장 자바 기술 시스템 소개

#### 1.1 들어가며

자바의 특징
- 하드웨어 플랫폼이라는 족쇄를 제거하여 "한 번 작성하면 어디서든 실행된다"라는 이상을 실현
- 상당히 안전한 메모리 관리 시스템을 갖춘 덕에 메모리 누수 문제와 엉뚱한 메모리를 가리키는 문제 대부분을 피할 수 있다.
- 런타임에 핫 코드를 감지, 컴파일하고 최적화하여 자바 애플리케이션이 최상의 성능을 내도록 도와준다.
- 표준 API 자체가 풍부할 뿐 아니라 수많은 기업과 오픈 소스 커뮤니티에서 제공하는 다양한 기능의 서드 파티 라이브러리를 활용할 수 있다.


#### 1.2 자바 기술 시스템
- 자바 프로그래밍 언어, 자바 가상 머신 구현, 클래스 파일 포맷, 자바 클래스 라이브러리 API, 다른 기업과 오픈 소스 커뮤니테이서 제공하는 서드 파티 클래스 라이브러리
![자바](../image/자바기술시스템의구성요소.png)

#### 1.3 자바의 과거와 현재
#### 1.3.1 자바의 탄생
제임스 고슬링

#### 1.3.5 모던 자바의 시작
2014년: JDK 8
- JEP 126: 람다식 지원
- JEP 104: 자바스크립트 엔진 내장
- JEP 150: 새로운 시간 및 날짜 API
- JEP 122: 핫스팟에서 영구 세대 완전 제거

#### 1.4 자바 가상 머신 제품군
다양한 VM 들이 있었음

#### 1.5 자바 기술의 미래
그랄VM, 발할라, 앰버, 파나마 등
지속적으로 발전중 : var, switch, Pattern Matching, Records, Sealed Classes

#### 1.6 실전: 내 손으로 빌드하는 JDK

## 2부 자동 메모리 관리

### 2장 자바 메모리 영역과 메모리 오버플로

#### 2.1 들어가며
자바 개발자는 가상 머신이 제공하는 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제를 짝지어 코딩하지 않아도 메모리 누수나 오버플로 문제를 거의 겪지 않는다.
하지만 통제권을 위임했기 때문에 문제가 한번 터지면 가상 머신의 메모리 관리 방식을 이해하지 못하는 한 해결하기가 상당히 어렵다.

#### 2.2 런타임 데이터 영역
JVM은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다.
어떤 영역은 프로세스의 시작과 동시에 만들어지며, 어떤 영역은 사용자 스레드의 시작/종료에 맞춰 생성/삭제된다.

![img.png](../image/jvm데이터영역.png)

##### 2.2.1 프로그램 카운터 (pc)
**프로그램 카운터 레지스터**는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기'라고 생각
바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다.
프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현하는 것이다. 예외 처리나 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어진다.

자바 가상 머신에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다.
따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다.
이 메모리 영역을 **스레드 프라이빗 메모**라고 한다.

스레드가 자바 메서드를 실행 중일 떄는 실행 중인 바이트코드 명령어의 주소가 프로그램 카운터에 기록된다.
한편 스레드가 네이티브 메서드를 실행 중일 떄 프로그램 카운터 값은 Undefined다. 프로그램 카운터 메모리 영역은 OutOfMemoryError조건이 명시되지 않는 유일한 영역

##### 2.2.2 자바 가상 머신 스택


