CTO의 스프링

[1장 오브젝트와 의존관계](#1장-오브젝트와-의존과나계)   
[2장 테스트](#2장-테스트)    
[3장 템플릿](#3장-템플릿)  
[4장 예외](#4장-예외)  
[5장 서비스 추상화](#5장-서비스-추상화)   
[6장 AOP](#6장-AOP)

### 스프링이란 무엇인가?

스프링의 핵심 프로그래밍 모델

1. IoC/DI
2. 서비스 추상화
3. AOP

스프링의 성공요인

- 단순함
- 유연성

## Vol.1 스프링의 이해와 원리

### 1장 오브젝트와 의존관계

- 리팩토링 중복 코드의 메소드 추출, 테스트 코드를 통한 동작 확인
- 상속을 통한 확장 팩토리 메소드 패턴 - 오브젝트를 생성하는 방식이 다름 템플릿 메소드 패턴 - 슈퍼클레스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔
  메소드를 훅 메소드라고 함

- 인터페이스 도입

디비 관련 서비스를 주입 받아서 사용하면 한 곳에서만 코드를 수정해주면 된다.

개방 폐쇄 법칙 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방되어 있다. 반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

SOLID

- SRP : 단일 책임 원칙
- OCP : 개방 폐쇄 원칙
- LSP : 리스코프 치환 원칙
- ISP : 인터페이스 분리 원칙
- DIP : 의존관계 역전 원칙

#### 높은 응집도와 낮은 결합도

#### 전략 패턴

전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고 
이를 구현한 구체적인 알고리즘(독립적인 책임으로 분리가 가능한 기능) 클래스를 필요에 따라 바꿔서
사용할 수 있게 하는 디자인 패턴이다.

#### 1.4 제어의 역전

오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 
모든 종류의 작업을 사용하는 쪽에서 제어하는 구조임, 제어의 역전이란 이런 제어 흐름의 개념을 거꾸로
뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음

#### 1.5 스프링의 IoC

스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부른다.

@Configuration - 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
@Bean - 오브젝트 생성을 담당하는 IoC용 메소드라는 표시

#### 1.6 싱글톤 레지스트리와 오브젝트 스코프

스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.

#### 1.7 의존관계 주입

B가 변하면 A에 영향을 미친다. A가 B를 의존한다.

의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

### 2. 테스트

#### 작은 단위의 테스트

#### 자동수행 테스트 코드

#### 테스트 결과의 일관성

#### 동일한 결과를 보장하는 테스트

#### 포괄적인 테스트

#### TDD

실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다. -> 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

#### 테스트 코드 개선

- @Before
- fixture

#### 2.4 스프링 테스트 적용

#### 2.4.2 DI와 테스트

침투적 기술과 비침투적 기술 침투적 기술은 기술을 적용했을 대 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 말한다. 침투적 기술을 사용하면 애플리케이션
코드가 해당 기술에 종속되는 결과를 가져온다. 반면에 비침투적인 기술은 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다.

#### 2.5 학습 테스트로 배우는 스프링

장점

- 다양한 조건에 따른 기능을 손쉽게 확인 가능
- 학습 테스트 코드를 개발 중에 참고할 수 있음
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와줌
- 테스트 작성에 대한 훈련이 됨
- 새로운 기술을 공부하는 과정이 즐거워짐

#### 2.5.3 버그 테스트

- 테스트의 완성도를 높여준다.
- 버그의 내용을 명확하게 분석해줌
- 기술적인 문제를 해결하는데 도움이 된다.

### 3장 템플릿

1. 중복 코드 제공 X
2. 템플릿 메소드 패턴의 적용 X
3. 전략 패턴의 적용 X
4. DI 적용을 위한 클라이언트/컨텍스트 분리

```java
    public void deleteAll() throws SQLException{
        StatementStrategy st=new DeleteAllStatement();
        jdbcContextWithStrategy(st);
    }
```

#### 3.3 JDBC 전략 패턴의 최적화

#### 3.4 컨텍스트와 DI

UserDao에서 jdbcContext를 DI 받아서 사용하도록 변경


### 4장 예외

예외가 발생했는데 아무것도 하지 않고 넘어가는 것은 원치 않는 예외가 발생하는 것보다 훨씬 나쁜 일이다.

#### 4.1.2 예외의 종류와 특징

Error : OutOfMemoryError, ThreadDeath

Exception과 체크 예외 : IOException, SQLException

RuntimeException : NullPointException, IllegalArgumentException 개발자 부주의에 의해 발생할 수 있는 경우

-> 최근 새로 등장하는 자바 표준 스펙의 API들은 예상 가능한 예외상황을 다루는 예외를 체크 예외로 만들지 않는 경향이 있다.


#### 4.1.3 예외 처리 방법
- 예외 복구 : Retry
- 예외처리 회피 : 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.
- 예외 전환 : 중복이면 DuplicateException 등으로 전환


#### 4.1.4 예외처리 전략
첫 번째 방법 정상과 비정상을 다른 리턴 값
두 번째 방법 정상적인 흐름은 그대로두고 비정상은 Exception

예외 전환
DB마다 DuplicatedKeyException return 값이 다르므로 동일하게 exception으로 잡아줌


```
- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다.
- 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야한다.
- 좀 더 의미 있는 예외로 변경하거나, 불필요한 catch/throws를 피하기 위해 런타이 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
- 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
- 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.
- JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
- SQLException의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
- 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.
- DAO를 데이터 엑세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다.
```

### 5장 서비스 추상화

#### 5.1. 사용자 레벨 관리 추가
enum을 이용

코드 개선

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다.

서비스 추상화하고 목 오브젝트를 이용해 테스트 할 수 있음

### 6장 AOP

- 트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일한 인터페이스를 구현하면 DI의 확장 기능을 이용해 클라이언트의 변경 없이도
깔끔하게 분리된 트랜잭션 부가기능을 만들 수 있다.
- 트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다.
- 목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손쉽게 고립된 테스트로 만들 수 있다.
- DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
- 번거러운 프록시 클래스 작성은 JDK의 다이내믹 프록시를 사용하면 간단하게 만들 수 있다.
- 다이내믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다. 스프링은 자동 프록시 생성 기술에 대한
추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.
- 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 활용할 수 있다. 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는
프록시를 스프링 컨테이너 초기화 시점에 자동을 만들어준다.
- 포인트컷은 AspectJ 포인틐ㅅ 표현식을 사용해서 작성하면 편리하다.
- AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.
- 스프링은 자주 사용되는 AOP설정과 트랜잭션 속성을 지정하는데 사용할 수 있는 전용 태그를 제공한다.
- AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 @Transactional 애노테이션을 사용하는 방법이 있다.
- @Transactional을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.


### 7장 스프링 핵심 기술의 응용

- SQL 처럼 변경될 수 있는 텍스트로 정보는 외부 리소스에 담아두고 가져오게 만들면 편리하다.
- 성격이 다른 코드가 한데 섞여 있는 클래스라면 먼저 인터페이스를 정의해서 코드를 각 인터페이스별로 분리하는게 좋다. 다른 인터페이스에 속한 기능은 인터페이스를 통해 접근하게 만들고, 간단히 자기참조 빈으로 의존관계를 만들어 검증한다.
검증을 마쳤으면 아예 클래스를 분리해도 좋다.
- 자주 사용되는 의존 오브젝트는 디폴트로 미리 정의해두면 편리하다.
- XML과 오브젝트 매핑은 스프링의 OXM 추상화 기능을 활용한다.
- 특정 의존 오브젝트를 고정시켜 기능을 특화하려면 멤버 클래스로 만드는 것이 편리하다. 기존에 만들어진 기능과 중복되는 부분은 위임을 통해 중복을 제거하는게 좋다.
- 외부의 파일이나 리소스를 사용하는 코드에서는 스프링의 리소스 추상화와 리소스 로더를 사용한다.
- DI를 의식하면서 코드를 작성하면 객체지향 설계에 도움이 된다.
- DI에는 인터페이스를 사용한다. 인터페이스를 사용하면 인터페이스 분리 원칙을 지키는데도 도움이 된다.
- 클라이언트에 따라서 인터페이스를 분리할 때, 새로운 인터페이스를 만드는 방법과 인터페이스를 상속하는 방법 두 가지를 사용할 수 있다.
- 애플리케이션에 내장하는 DB를 사용할 때는 스프링의 내장형 DB 추상화 기능과 전용 태그를 사용하면 편리하다.



