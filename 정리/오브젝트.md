## 오브젝트 - OBJECTS

[1. 객체, 설계](#1-객체-설계)   
[2. 객체지향 프로그래밍](#2-객체지향-프로그래밍)    
[3. 역할, 책임, 협력](#3-역할-책임-협력)     
[4. 설계 품질과 트레이드오프](#4-설계-품질과-트레이드오프)    
[5. 책임 할당하기](#5-책임-할당하기)    
[6. 메시지와 인터페이스](#6-메시지와-인터페이스)  
[7. 객체 분해](#7-객체-분해)    
[8. 의존성 관리하기](#8-의존성-관리하기)  
[9. 유연한 설계](#9-유연한-설계)  
[10. 상속과 코드 재사용](#10-상속과-코드-재사용)  
[11. 합성과 유연한 설계](#11-합성과-유연한-설계)
[12. 다형성](#12-다형성)
[13. 서브클래싱과 서브타이핑](#13-서브클래싱과-서브타이핑)  
[14. 일관성 있는 협력](#14-일관성-있는-협력)  

### 1. 객체, 설계

로버트 L. 글래스 실무가 먼저다  
소프트웨어 설계와 소프트웨어 유지보수에서 실무가 이론보다 앞서고 있음

> 소프트웨어 모듈의 세 가지 목적
> 1. 실행 중에 제대로 동작
> 2. 변경을 위해 존재
> 3. 코드를 읽는 사람과 의사소통
> - 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다. - 마틴 아저씨

1장의 Theater 예제는 관람객의 돈을 극장이 빼가고 티켓박스의 돈을 가져간다. 우리의 상식과는 다르게 동작하고 있음, 변경에도 취약함 --> 객체 사이의 의존성의 문제 (최소한의 의존성만 유지해야함) 결합도가
높으면 좋지 않다.

> 관람객과 판매원을 자율적인 존재로 만들자!


물리적으로 객체 내부의 세부적인 사항을 감추는 것은 캡슐화(encapsulation)라 한다.    
-> 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.

!! 캡슐화와 응집도 핵심 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것

> 각 객체는 자신을 스스로 책임

계속 코드를 개선 ---> 코드를 개선하다보니 TicketSeller가 TicketOffice 의 구현이 아닌 인터페이스에만 의존하게 되었다 하지만 변경 전에는 존재하지 않았던 audience와의 의존성이 생겼다.

- audience에 대한 결합도와 ticketOffice의 자율성을 모두 만족시키는 방법이 잘 떠오르지 않음 트레이드오프의 시점이 왔다.

- 설계는 균형의 에술

> 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.  
> 레베카 워프스브록은 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인환라고 부른다.

### 2. 객체지향 프로그래밍

DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름을 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에 위임한다. 실제로는
DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메소드가 실행될 것이다. 이처럼 부모 클래스에 기본적인 알고리즘의 흐르을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을
TEMPLATE METHOD 패턴이라고 한다.

책 예제의 코드 상에서는 Movie는 DiscountPolicy에 의존한다. 그러나 실행 시점에는 Movie의 인스턴스는 AmountDiscountPolicy나 PercentDiscountPolicy의 인스턴스에
의존하게 된다. -> 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있따. 한 가지 간과해서 안 되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 반면 코드의
의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연하고 확장 가능해진다. 이와 같은 의존성의 양면성은 설계가 트레이드 오프의 산물이라는 사실을 보여준다.

> 상속과 인터페이스  
> 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
>
> 다형성    
> Movie는 DiscountPolicy의 인스턴스에게 calculateDiscountAmount 메시지를 전송하고 실행되는 메서드는 연결된 객체의 클래스가 무엇인가에 따라 달라진다.
> 이를 다형성이라고한다.

- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 부른다.

- 구현 상속은 순수하게 코드를 재사용하기 위한 것, 인터페이스 상속은 다형적인 협력을 위해 부모 클래스의 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것

NoneDiscountPolicy를 만들어서 Movie, DiscountPolicy는 수정하지 않고 애플리케이션의 기능을 확장하였다.

-> 할인 금액이 0원이라는 사실을 효과적으로 전달할 수 있지만 NoneDiscountPolicy를 추가한 것은 과하다고 생각할 수 있다. 여기서 이야기하는 사실은 구현과 관련되 모든 것들이 트레이드오프의 대상이 될
수 있다는 사실이다.
> 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 비록 아주 사솟한 결정이라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.
> 고민하고 트레이드오프해야한다.

- 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 인스턴스 변수로 연결하는 방법을 사용하면 실행 시점에 할인 정책을 간단하게 변경할 수 있음

### 3. 역할, 책임, 협력

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고한다.

- 협력이 설계를 위한 문맥을 결정한다. 객체가 협렵에 참여하기 위해 수행하는 로직은 책임이라고한다. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다.

--> 메시지가 객체를 결정해야지

1. 최소한의 인터페이스를 가질 수 있게 되며
2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.

영화 도메인에 요금을 계산하라는 메시지를 전송하고 구현하면 두 가지 종류의 가격 할인 정책이 존재하기 때문에 중복으로 만들어야한다. 이런 중복 문제를 해결하기 위해서는 객체가 아닌 책임에 초점을 맞춰야 한다.

협력 ---> 역할 ---> 객체 ---> 클래스 reference select from instance of

설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고 역할과 객체를 명확하게 구분하는 것은 그렇제 중요하지는 않다. 따라서 애매하다면 단순하게 객체로 시작하고 반복적으로 책임과
협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법

객체에서 중요한 것은 행동!!!!!

### 4. 설계 품질과 트레이드오프

객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.

- 첫 번째 방법은 상태를 분할의 중심축으로 삼는 방법
- 두 번째 방법은 책임을 분할의 중심축으로 삼는 방법

설계 트레이드오프 - 캡슐화, 응집도, 결합도

높은 응집도, 낮은 결합도, 캡슐화의 정도가 응집도와 결합도에 영향을 미친다.

rectangle 의 너비와 높이를 증가시키는 코드가 필요하다고 한다면 외부가 아니라 객체 내부에서 관리하도록 캡슐화를 한다면 값의 이름이 변경이나 로직을 변경하더라고 변경할 부분이 별로 없음!

캡슐화 - 객체가 자기 스스로 책임지도록 하자

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

### 5. 책임 할당하기

데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 책임에 초점을 맞추는 것이다. 책임 할당 과정은 일종의 트레이드오프 활동이다. 동일한 문제를 해결할 수 있는 다양한 책임
할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 띠리 달라진다. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다.

-> 책임 주도 설계를 향해

- 데이터보다 행동을 먼저 결정
- 협력이라는 문맥 안에서 책임을 결정

> 1. 이 객체가 수행해야 하는 책임은 무엇인가 2. 이 책임을 수행하는 데 필요한 데이터는 무엇인가

메시지가 클라이언트의 의도를 표현한다는 사실에 주목. 클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐 그리고 그 메시지를 수신하기로 결정된 객체는
메시지를 처리할 '책임'을 할당 받게 된다.

GRASP - General Responsibility Assignment Software Pattern

> Information Expert 패턴 - 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당
> -> 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있음

> Low Coupling 패턴 - 설계도의 전체저긴 결합도가 낮게 유지되도록 책임을 할당

> High Cohesion 패턴 - 높은 응집도를 유지할 수 있게 책임을 할당 (Screening의 가장 중요한 책임은 예매를 생성하는 것)

> Creator 패턴 - 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?

- B가 A 객체를 포함하거나 참조한다.
- B가 A 객체를 기록한다.
- B가 A 객체를 긴밀하게 사용한다.
- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. 위 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당

응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미한다. 따라서 낮은 응집도가 초래하는 문제를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 한다.

클래스가 하나 이상의 이유료 변경돼야 한다면 응집도가 낮은 것 코드를 통해 변경의 이유를 파악할 수 있는 방법

1. 인스턴스 변수가 초기화 되는 시점을 살펴본다. -> 함께 초기화되는 속성을 기준으로 코드를 분리
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다. -> 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

> Polymorphism 패턴 - 객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 어떻게 할당해야하나?
> 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당

> Protected Variations 패턴 - 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당

##### 변경과 유연성

설계를 주도하는 것은 변경이다. 개발자로서 변경에 대비할 수 있는 두 가지 방법이 있다. 하나는 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수
있도록 코드를 유연하게 만드는 것 -> 대부분의 전자가 좋지만 변경이 반복적으로 발생한다면 복잡성이 상승하더라도 유연성을 추가하는 두 번째 방법이 좋다.

상속을 이용하고 있기 때문에 실행 중에 영화의 할인 정책을 변경하기 위해서는 새로운 인스턴스를 생성한 후 필요한 정보를 복사해야 한다. --> 상속 대신 합성을 사용

> 유연성은 의존성 관리의 문제

```java
Movie movie=new Movie("타이타닉",Duration.ofMinutes(120),Money.wons(1000),new AmountDiscountPolicy(...));

        movie.changeDiscountPolicy(new PercentDiscountPolicy(...));
```

합성을 사용한 경우 할인 정책이 추가되더라도 할인 정책을 변경하는데 필요한 추가적인 코드를 작성할 필요가 없다.

긴 메서드는 다양한 측면에서 코드의 유지 보수에 부정적인 영향을 미침

- 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는데 너무 많은 시간이 걸린다.
- 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.
- 로직의 일부만 재사용하는 것이 불가능하다.
- 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.

정 힘들면 데이터 주도 설계 후 리팩터링을 하면서 각자 책임에 맞게 할당하는 방법도 있다.

### 6. 메시지와 인터페이스

객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받은 메시지다. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설꼐 원칙과 기법을 익히고 적용해야 한다.

Screening -> 가격을 계산하라 Movie 예매 요금 <- 정보가 부족 Screening -> 할인 요금을 계산하라 Movie 할인 요금 <-

```kotlin
condition.isSatisfiedBy(screening)
수신자 오퍼레이션명 인자
```

-> 오퍼레이션명의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.

객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 대문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.

- 디미터 법칙 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라

> 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다.
> this 객체
> 메서드의 매개변수
> this의 속성
> this의 속성인 컬렉션의 요소
> 메서드 내에서 생성된 지역 객체

-> shy code를 통해서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있음

기차충돌 - 클래스의 내부 구현이 외부로 노출 됐을 때 나타나는 전형적인 형태

Tell, Don't Ask 절차적인 코드는 정보를 얻은 후에 결정하고, 객체지향 코드는 객체에게 그것을 하도록 시킨다.

무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 의도를 드러내는 선택자(Intention Revealing Selector)라고 한다.

! 잊지 말아야 하는 사실은 설계가 트레이드오프의 산물이라는 것이다.

명령-쿼리 분리(Command-Query Separation)

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

분리하지 않는다면 처음에는 조건을 만족해서 false 이지만 바로 다시 호출했을 때 true 를 반환하게 된다.

isSatisfied가 두 가지 역할을 했었음

수학과 컴퓨터 함수의 차이점 - 부수효과

명령형 프로그래밍- 연산을 적절한 순서대로 나열함으로써 프로그램을 작성, 함수형 프로그래밍 - 부수효과가 존재하지 않는 수학적인 함수에 기반

### 7. 객체 분해

문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력이 급격하게 떨어지는데 이것을 인지 과부화라고 부른다. 인지 과부화를 방지하는 가장 좋은 방법은 단기 기억 안에 보관할 정보의 양을
조절하는 것이다. 한 번에 다뤄야 하는 정보의 수를 줄이기 위해 본질적인 정보만 남기고 불필요한 세부 상항을 걸러내면 문제를 단순화할 수 있을 것이다. 이처럼 불필요한 정보를 제거하고 현재의 문제 해결에 필요한
핵심만 남기는 작업을 추상화라고 한다.

큰 문제를 해결 가능한 작은 문제로 나누는 작업을 분해(composition)라고 부른다. --> 한 번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만 추상화를 더 큰 구모의 추상화로 압축시킴으로써 단기
기억의 한계를 초월할 수 있다.

#### 프로시저 추상화와 데이터 추상화

현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 프로시저 추상화와 데이터 추상화다.

시스템을 분해하는 방법을 결정하려면 먼저 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지를 결정해야 한다.

프로시저 추상화를 중심으로 시스템을 분해하기로 결정했다면 기능 분해의 길로 들어서는 것이다. 기능 분해는 알고리즘 분해라고 부르기도 한다.

데이터 추상화를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 한다. 하나는 데이터를 중심으로 타입을 추상화하는 것이고 다른 하나는 데이터를 중심으로 프로시저를 추상화하는 것이다. 전자를
추상 데이터 타입이라고 불고 후자를 객체지향이라고 부른다.

#### 프로시저 추상화와 기능 분해

하향식 기능 분해의 문제점

- 시스텝은 하나의 메인 함수로 구성돼 있지 않다.
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

> 실제 시스템에 정상이란 존재하지 않는다.

--> 설계가 필요한 이유는 변경에 대비하기 위한 것이다.

하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다. 이것은 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지가
아니라 어떻게(how) 동작해야 하는지에 집중하도록 만든다.

> 하향식 설계와 관련된 모든 문제의 원인은 결합도다.

함수는 상위 함수가 강요하는 문맥에 강하게 결합된다. 이러한 경우 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것이 생각보다 쉽지 않다.

데이터 변경으로 인한영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다. 이를 위해 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해
데이터에 접근해야 한다. 즉 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다.

이것이 바로 의존성 관리의 핵심이다. 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지 않는 부분을 명확하게 분리하고 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하라. 기능 분해가
가진 본질적인 문제를 해결하기 위해 이 같은 개념을 기반으로 한 정보 은닉과 모듈이라는 개념을 제시하였다.

> 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다. 그러나 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.
> 이것은 수학과 아주 유사하다. 수학 교과서는 계산의 과정을 논리적인 순서로 서술한다. 공인되고 증명된 이론이 뒤이은 이론을 증명하기 위해 사용된다.
> 그러나 이론은 그런 방식이나 순서로 ㅅ개발되거나 발견되 것이 아니다.

#### 모듈

모듈의 장점과 한계

- 모듈 내부의 변수가 변경되더라도 무듈 내부에만 영향을 미친다.
- 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

비록 모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만 태생적으로 변경을 관리하기 위한 구현 기법이기 때문에 추상화 관점에서의 한계점이 명확하다. -> 데이터를 은닉하기 위해 추상데이터라는 것도 나왔음

#### 클래스

클래스는 추상 데이터 타입인가?

추상 데이터 타입은 타입을 추상화한 것이고 클래스는 절차를 추상화한 것이다.
> 객체지향은 절차 추상화다.

객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다. - 객체가 메시지를 처리할 적절한 메서드를 선택한다. 모든 설계 문제가 그런 것처럼 조건문을 사용하는 방식을 기피하는 이유 역시 변경 때문이다. 이처럼
기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 개방-폐쇄 원칙이라고 부른다.

#### 협력이 중요하다.

객체지향에서 중요한 것은 역할, 책임, 협력이다.

> 객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라.

### 8. 의존성 관리하기

잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.

#### 의존성 이해하기

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존ㄴ성이 존재하게 된다. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.

- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

#### 런타임 의존성과 컴파일타임 의존성

객체지향 애플리케이션에서 런타임의 주인공은 객체다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다. 반면 코드 관점에서 주인공은 클래스다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의
의존성이다.

> 객체지향 프로그램의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있다. 코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함된다.
> 그러나 프로그램의 실행 시점 구조는 협력하는 객체에 따라서 달라질 수 있다. 즉. 구조는 전혀 다른 별개의 독립성을 갖는다. 하나로부터 다른 하나를 이해하려는 것은
> 생태계의 동적인 성질을 식물과 동물과 같은 정적 분류 구조를 바탕으로 이해하려는 것과 똑같다. 컴파일 시점의 구조와 실행 시점 구조 사이에 차이가 있기 때문에
> 코드 자체가 시스템의 동작 방법을 모두 보여줄 수 없다. 시스템의 실행 시점 구조는 언어가 아닌 설계자가 만든 타입들 간의 관련성으로 만들어진다. 그러므로 객체와 타입 간의
> 관계를 잘 정의해야 좋은 실행 구조를 만들어 낼 수 있다.

#### 컨텍스트 독립성

클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 컨텍스트
독립성이라고 부른다. 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다. 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기
떄문이다. 결과적으로 설계는 더 유연해지고 변경에 탄력적으로 대응할 수 있게 될 것이다.

#### 의존성 해결하기

컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다. 의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다.

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

#### 유연한 설계

#### 의존성과 결합도

바람직한 의존성은 재사용성과 관련이 있다.

의존성이 바람직할 때 두 요소가 느슨한 결합도 또는 약한 결합도를 가진다고 말한다. 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도 또는 강한 결합도를 가진다고 말한다.

#### 추상화에 의존하라.

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성 아래쪽으로 올수록 클라이언트가 알아야 하는 지식의 양이 적어지기 대문에 결합도가 느슨해진다.

setter로 메서드 인자를 사용하는 경우 명시적인 의존성이라고 하며 직접 관련 인스턴스를 생성하는 방식은 숨겨진 의존성이라고 할 수 있다.

#### new는 해롭다.

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높다.
- new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가
  높아진다.
  
#### 가끔은 생성해도 무방하다.

주로 협력하는 기본 객체를 설정하고 싶은 경우 - 기본 객체를 생성하는 생성자를 추가하고 이 생성자에서 인스턴스를 인자로 받는 생성자를 체이닝한다.

구체 클래스에 의존하게 되더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향으로 코드를 작성할 수 있다. -> 두 마리 토끼 다 잡는 것이 9장 FACTORY

#### 표준 클래스에 대한 의존은 해롭지 않다.

List 같은 경우 - 그럼에도 불구하고 가능한 한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다.

#### 조합 가능한 행동

어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다. 유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써
애플리케이션의 기능을 쉽게 확장할 수 있다.

> 객체지향 시스템은 협력하는 객체들의 네트워크로 구성돼 있다. 시스템은 객체를 생성해 서로 메시지를 주고 받을 수 있게 조립하는 과정을 거쳐 만들어진다.
> 시스템의 행위는 객체의 조합(객체의 선택과 연결 방식)을 통해 나타나는 특성이다.
> 따라서 시스템에 포함된 객체의 구성을 변경해 (절차적인 코드를 작성하기보다는 인트선트 추가나 제거 또는 조합을 달리해서) 시스템의 작동 방식을 바꿀 수 있다.
> 이러한 객체 구성을 관리할 목적으로 작성하는 코드를 객체 네트워크의 행위에 대한 선언적인 정의라고 한다. 시스템을 이런 방식으로 구축하면 방법이 아니라 목적에 집중할 수 있어
> 시스템의 행위를 변경하기 더 쉽다.

### 9. 유연한 설계

#### 개방-폐쇄 원칙
소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

- 확장에 대해 열려 있다. 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다. 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

#### 추상화가 핵심이다
개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것

> 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다. 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.
> 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.

#### 생성 사용 분리
결합도가 높아질수록 개방- 폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다. 알아야 하는 지식이 많으면 결합도도 높아진다. 
부적절한 곳에서 객체를 생성하면 문제가 생긴다.
동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하면 문제가 생길 수 있다.

> 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 연결하는)시작 단계와 (시작 단계 이후에 이어지는)실행 단계를 분리해야 한다.

#### FACTORY 추가하기
객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다. 이처럼 생성과 사용을 분리하기 위해 객체 생성에
특화된 객체를 FACTORY라고 한다.

#### 의존성 주입

사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입(Dependency Injection)이라고 부른다.
- 생성자 주입
- setter 주입
- 메서드 주입

SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지, 어디에 있는지를 몰라도 되게 해준다. 하지만 인터페이스 어디에도 의존성에 대한 정보가 없다.
-> 의존성을 내부로 감출 경우 의존성과 관련된 문제가 컴파일 타임이 아닌 런타임에가서야 발견된다.

#### 의존성 역전 원칙
상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 된다.

하위 수준의 이슈로 인해 상위 수준에 위치하는 클래스들을 재사용하는 것이 어렵다면 이것은 문제가 된다.
이 경우에도 추상화를 이용해 해결할 수 있다. -- 가장 중요한 것은 추상화에 의존하는 것이다.

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
--> 의존성 역전 원칙
   
#### 협력과 책임 중요하다.
의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중하라.


### 10. 상속과 코드 재사용

재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법

#### 상속과 중복 코드
> DRY원칙 (Don't Repeat Yourself)
> 중복 코드는 변경을 방해한다.
> 프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 것이다.
> 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.

#### 중복과 변경
Call -> Phone, NightlyDiscountPhone -> tax가 추가 중복 코드 양쪽을 수정하게 됨 -> 중복 코드는 새로운 중복 코드를 부름

#### 타입 코드 사용하기
요금제를 구분하는 타입 코드를 추가하고 타입 코드의 값에 따라 로직을 분기시켜 Phone과 NightlyDiscountPhone을 하나로 합칠 수 있

해결하는 방법 - 상속
##### 상속을 이용해서 중복 코드 제거하기

상송을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정ㅇ르 정확하게 이해해야 한다. 이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한
정확한 지식을 가져야 한다는 것을 의미한다.
따라서 상속은 결합도를 높인다. 그리고 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 이 코드를 수정하기 어렵게 만든다.

> !상속을 위한 경고 1
> 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라

#### 취약한 기반 클래스 문제
부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제라고 부른다. 상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성임
취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다. 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.

객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 때문이다. 상속을 사용하면 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도
자식 클래스가 영향을 받기 쉬워진다.

> 초기 Vector 를 상속 받는 Stack 문제
> 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야한다.

> !상속을 위한 경고 2
> 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

> !상속을 위한 경고 3
> 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

-> 설계는 트레이드오프, 상속은 코드 재사용을 위해 캡슐화를 희생한다. 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이회의 다른 방법을 사용해야 한다.

#### 부모 클래스와 자식 클래스의 동시 수정 문제

> !상속을 위한 경고 4
> 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.

#### 추상화에 의존하자
취약한 기반 클래스 문제를 완전히 없앨 수는 없지만 어느 정도까지 위험을 완화시키는 것은 가능 -> 추상화

- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

#### 차이를 메서드로 추출
-> 변하는 것으로부터 변하지 않는 것을 분리, 변하는 부분을 찾고 이를 캡슐화
다른 부분을 추출하고 같은 부분을 부모로 올림

```java
public abstract class AbstractPhone{
    
    private List<Call> calls = new ArrayList<>();
    
    public Money calculateFee() {
        Money result = Money.ZERO;
        
        for(Call call : calls) {
            result = reulst.plus(calculateCallFee());
        }
        
        return result;
    }
    
    abstract protected Money calculateCallFee(Call call);
}
```

#### 추상화가 핵심

#### 의도를 드러내는 이름 선택

#### 차이에 의한 프로그래밍
기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 차이에 의한 프로그래밍이라고 부른다.


### 11. 합성과 유연한 설계
상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다. 상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 데 비해 합성은 전체를 표현하는 객체가 부분을 표현한ㄴ 객체를 포함해서 부분 객체의 코드를 재사용한다.
상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.

상속 관계는 is-a 관계라고 부르고 합성 관계는 has-a 관꼐라고 부른다. 상속과 합성은 코드 재사용이라는 동일한 목적을 가진다는 점을 제외하면 구현 방법부터 변경을 다루는 방식에 이르기까지 모든 면에서 도드라진 차이를 보인다.

합성은 구현에 의존하지 않는다는 점에서 상속과 다르다. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스 의존한다. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게 된다.
상속 관계는 변경이 불가능하지만 합성 관계는 실행시점에 동적으로 변경할 수 있기 때문이다. 따라서 상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.

- 코드 재사용을 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법이다.

#### 상속을 합성으로 변경하기

##### 불필요한 인터페이스 상속 문제: java.util.Properties와 java.util.stack
합성 관계로 변경함으로써 클라이언트가 stack을 잘못 사용할 수 있는 가능성을 깔끔하게 제거해준다.

##### 메서드 오버라이딩의 오작용 문제: InstrumentedHashSet
불필요한 오퍼레이션들이 퍼블릭 인터페이스에 스며드는 것을 방지해준다. 

##### 부모 클래스와 자식 클래스의 동시 수정 문제: PersonalPlaylist
크게 달라지지 않음

> 몽키패치
> 몽키패치란 현재 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것을 가리킨다. 여러분에게 Playlist의 코드를 수정할 권한이 없거나 소스코드가 존재하지 않는다고 하더라도
> 몽키 패치가 지원되는 환경이라면 Playlist에 직접 remove 메서드를 추가하는 것이 가능하다.

#### 상속으로 인한 조합의 폭발적인 증가
- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
- 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

> 추상 메서드와 훅 메서드
> 개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다.
> 자식 클래스는 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다. 자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서
> 부모 클래스에서 정의 한 플로우에 개입할 수 있게 된다. 처음에 Phone 클래스에서 추상 메서드인 calculateFee와 afterCalculated를 선언하고 자식 클래스에서
> 두 메서드를 오버라이딩한 것 역시 이 방식을 응용한 것이다.
> 
> 추상 메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 한다는 것이다. 대부분의 자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 상속 계층 전반에 걸쳐
> 중복 코드가 존재하게 될 것이다. 해결 방법은 메서드에 기본 구현을 제공하는 것이다. 이처럼 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 훅 메서드라고 부른다.


상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 클래스 폭발 문제 또는 조합의 폭발 문제라고 부른다.

#### 합성 관계로 변경하기
상속과 달리 합성 관계는 런타임에 동적으로 변경할 수 있다. 합성을 사용하면 컴파일타임 의존성과 런타임 의존성을 다르게 만들 수 있다.
컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상승하기 때문에 코드를 이해하기 어려워진다. 하지만 설계는 변경과 유지보수를 위해 존재한다.
설계는 트레이드오프의 산물이다.

#### 기본 정책 합성하기
```java
public interface RatePolicy {
    Money calculateFee(Phone phone);
}
```

```java
public abstract class BasicRatePolicy implements RatePolicy {
    @Override
    public Money calculateFee(Phone phone) {
        Money result = Money.zero;
        
        for(Call call : phone.getCalls()) {
            result.plus(calculateCallFee(call));
        }
        
        return result;
    }
    
    protected abstract Money calculateCallFee(Call call);
}
```
- 부가 정책은 기본 정책이나 다른 부가 정책의 인스턴스를 참조할 수 있어야 한다. 다시 말해서 부가 정책의 인스턴스는 어떤 종류의 정책과도 합성될 수 있어야 한다.
- Phone의 입장에서는 자신이 기본 정책의 인스턴스에게 메시지를 전송하고 있는지, 부가 정책의 인스턴스에게 메시지를 전송하고 있는지를 몰라야 한다.
다시 말해서 기본 정책과 부가 정책은 협력 안에서 동일한 '역할'을 수행해야 한다. 이것은 부가 정책이 기본 정책과 동일한 RatePolicy 인터페이스를 구현해야 한다는 것을 의미한다.

#### 믹스인
믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다. 합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일
시점에 필요한 코드 조각을 조합하는 재사용 방법이다.

스칼라 트레이트 조합 -> 쌓을 수 있는 변경


### 12. 다형성

상속을 사용하려는 목적이 단순히 코드를 재사용하기 위해서라면 상속을 사용하지 말아야한다.

다형성이 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현된다.

#### 1. 다형성
- 강제 다형성은 : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다.
- 매개변수 다형성(제네릭 프로그래밍) : 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
- 포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력

#### 2. 상속의 양면성

##### 업캐스팅
- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 업캐스팅이라고 부른다.
- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 
아니라 실행 시점에 결정하기 때문에 가능하다. 이를 동적 바인딩이라고 부른다.


#### 동적 바인딩
전통적인 언어에서 함수를 실행하는 방법은 함수를 호출하는 것이다. 객체지향 언어에서 메서드를 실행하는 방법은 메시지를 전송하는 것이다.

#### 동적 메서드 탐색과 다형성

### 메서드 오버로딩
자바는 우리가 아는 그 오버로딩

c++ 에서는 상속 계층 안에서 동일한 이름을 가진 메서드가 공존해서 발생하는 혼란을 방지하기 위해 부모 클래스에 선언된 이름이 동일한 메서드 전체를
숨겨서 클라이언트가 호출하지 못하도록 막음 (이름 숨기기)


#### self super
메서드를 호출하는 것이 아닌 메시지를 전송하는 것이다!

> 클래스 기반의 상속과 객체 기반의 위임 사이에 기본 개념과 메커니즘을 공유한다는 점이다.



### 13. 서브클래싱과 서브타이핑

언제 상속을 사용해야 하는가?

상속 관계가 is-a 관계를 모델링하는가?
이것은 애플리케이션을 구성하는 어휘에 대한 우리의 관점에 기반한다. 일반적으로 "자식 클래스 부모 클래스"다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.

클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. 이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.


ex) 펭귄은 새다. 새는 날 수 있다.
-> is-a 가 아님

```kotlin
class Bird {
    
}

class FlyingBird : Bird() {
    
}

class Penguin : Bird() {
    
}
```

이처럼 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙이라고 한다.

그렇다면 상속은 언제 사용해야 하는가?
- 서브클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다. 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다. 서브클래싱을 구현 상속 또는 클래스 상속 이라고 부르기도한다.
-> 행동 호환성

- 서브타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다. 영화 예매 시스템에서 구현한 DiscountPolicy 상속 계층이 서브 타이핑. 
서브 타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 이때 부모 클래스는 자식 클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브타입이 된다.
서브타이핑을 인터페이스 상속이라고 부르기도 한다.
-> 대체 가능성


리스코프 치환 원칙

서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다. / 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.


### 14. 일관성 있는 협력





















