입문자를 위한 객체지향 안내서 - 조영호 (2022-07-09)

- 발표주제 : 입문자를 위한 객체지향 안내서
- 발표시간 : 3시간(2시간 30분 강의/30분 질의응답)
- 발표내용(안)
  - 동일한 요구사항을 절차적인 코드와 객체지향 적인 코드로 작성
  - 두 가지 방식의 코드를 응집도, 결합도, 캡슐화 관점에서 비교
  - 코드의 비교를 통해 객체지향의 장점과 결합도, 캡슐화에 대한 개념 이해


#### 영화 예매 도메인

도메인 : 해결하고자 하는 영역 (범위)
도메인 모델 : 중요한 것들을 정리하고 추상화 한 것

- Movie
- Screening
- Discount Policy (Amount Discount Policy, Percent Discount Policy)
- Discount Condition (Sequence Condition, Period Sequence)

! 영화에 상영을 하면서 예매에 가격을 계산하는 것

절차적, 객체지향

결과가 중요한 것이 아니고 이런 사고를 하기 때문에 이런 결과가 나오는 것이 중요하다.

#### 절차적 (Procedural)
읽는 순서와 실행순서가 같음

Data와 Process를 분리할 때 그런 결과가 나옴

Data 중심으로 ERD 를 그림 -> Data와 동일한 Class를 만듬(상태를 관리할 수 있음)

> 캡슐화한다고 private으로 get/set을 만들지만 이것이 캡슐화를 보존하지 않음
> get set은 누가 쓸지 모르고 전역 데이터처럼 돌게 된다.

! type 체크를 하는 것이 있으면 절차 지향이라고 할 수 있음 사용하는 애가 판단해야함
! 객체는 스스로가 스마트함 자기가 무엇인지 알고 있음, 데이터는 바보임
! 절차적인 코드는 중앙 집중식 제어 스타일 (쓰는 곳이 한 곳에 몰려 있음) 

#### 객체지향 설계
읽는 순서와 실행순서가 다를 수 있음

확장이 쉽고, 유지 보수성이 좋다.
Object(Process, Data)

> 어떤 Context가 있는 상황에서 어떤 Class가 필요하지라는 것이 중요하다
> Process, Data를 같이 사용 Process를 먼저 생각 Data는 마지막에 정한다 
> (TDD라고 생각해도 된다.) Interface를 만들고 Implements를 만든다. 실패 -> 성공 계속함
> Runtime을 만들고 Compile로 와야한다 객체 관점에서 설계한 후 그것을 담을 수 있는 Class를 만든다.

영화를 예매하기위한 Context를 만들고 Data를 만든다.


- 애플리케이션의 요구사항 파악
- 애플리케이션의 요구사항을 시스템의 책임으로 변환
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 수 있는 적절한 객체 선택
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움 요청

CRC(Candidate 위, Responsible 왼, Collaborator 오)카드 캔트백

예매 생성에 필요한 정보의 전문가에게 할당
도메인 개념을 기반으로 정보의 전문가에게 할당 (개념적 차이가 적음 - 유비쿼터스 랭귀지)
가장 적합한 정보를 가진 객체

> 객체와 Data의 차이는???
> 정보는 어떻게해서 계산해줄 수 있음 (누가 가장 적합한가)

1. 예매한다 상영을 ->> 상영: Screening 이 예매를 한다. || (자기 자신을 예매하는 것이 가장 자연 스러움) 대부분의 사람이 납득, 공통의 이해를 만듬
    - 가격 정보가 필요함
2. 가격에 대한 정보: Movie 는 영화가 가장 잘 알고 있음, 영화에게 메시지를 보냄
3. 할인가격을 알아야함: DiscountPolicy
4. 할인조건을 알아야함: DiscountCondition

응집도가 떨어지는 클래스는? 메소드에 필요한 필드만 속성으로 넣기 때문에 응집도가 떨어진다.
클래스 크기가 작고 많아짐 (응집도, 결합도, 캡슐화에 좋아짐) 

패키지, 클래스를 나눔 명사를 일단 한정지을 수 있기 때문에 객체지향이 좋음
(서비스, 도메인으로 패키지를 나누면 찾기 힘듬, 패키지, 객체를 잘 나눠서 사용해야함, 절차지향적인 코드는 처음부터 다시 읽어야함)

위임식/분산식 제어 스타일이다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
의존성
trade off : parameter를 넘기는 경우 객체를 넘기는 경우
의존성 A가 B에게 의존한다. B가 변경이 되면 A도 변경 될 수 있음

의존성은 4가지 정도가 있다.
field, method parameter, local variable, return value

끊기 위한 방법은
1. 의존성을 끊는 것이 좋다.
2. 단방향이 좋고

의존성이 있을때 변경에 영향도가 크면 결합도가 높다 작으면 결합도가 낮다.

라이프 사이클이 같으면
aggregate
lifecycle constraint 가 비슷하면 양뱡향 의존성이 있을 수 있다고 생각함

만약 그것이 아니라면
parameter를 넘기는 것이 좋겠다. (2가지를 넣는 방법, 객체로 묶는 방법)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

### 설계 이야기

응집도 결합도 캡슐화는 이런 느낌이다
응집도가 높은, 결합도가 느슨한, 잘 캡슐화된

응집도 - 동일한 기능에 집중
결합도 - 알고 있는 것이 많을 수록 결합도가 높다. (메시지, 이벤트로 하는 것이 결합도가 높다함)
캡슐화 - 외부에 공개된 메소드

설계란?
다른 방식의 코드 배치
코드를 배치하는 방식

변경하기 좋은 코드가 확장성 있는 코드는 아니다.

좋은 설계 -> 변경하기 쉽게 코드를 배치하는 방식
! 모든 설계 원칙과 용어는 변경과 관련
SOLID (변경과 관련된 것)

strategy pattern, composite pattern을 이런 구조로 짜야한다는 것만 아는 것이 제일 나쁨
다양한 디자인 패턴의 목적은 변경을 감추는 것 (기능 조합을 감추고, 알고리즘을 감추고 싶을 때) >> 변경관점에서 봐야한다.

#### 변경 관점에서

##### 응집도란
 -> 모듈 내부 요소들이 함꼐 변경되는 정도, 높은 응집도 : 모듈 전체가 동일한 이유로 변경 
git conflict 한 명이 하나의 코드만 수정하고 싶어가 응집도
절대 안 변하는 것은 class가 커도 상관 없음 엄청 자주 변경 되면 method 단위로 찢는 것이 좋을 수 있음
if가 안 좋은 것? 변경 되었을 때 어느 곳에서는 누락이 될 수 있기 떄문에 (SRP)


##### 결합도란
 -> 모듈을 변경할 때 다른 모듈이 함꼐 변경되는 정도 10번 바뀔 떄 7번 or 3번 바뀌냐 
안 바뀌면 결합도가 높아도 상관 없긴함 
의존성을 관리하는 것이다. > 의존성 때문에 버그가 발생하기 때문이다. 전역변수 변경에 영향을 준다.
의존성은 있지만 결합도를 낮추는 방식으로 가야한다. (안정적인 추상화에 의존하도록 설꼐)

구현과 추상화의 분리
구현 - 자주 변경되는 불안전한 부분
추상화(abstraction) - 자주 변경되지 않는 안정적인 부분, 인터페이스와 구현의 분리

> 결합도란 상대적인 것이다. 내가 이것을 바꿨을 때 ide에 빨간불이 많이 나오면 결합도가 높은 것이다.
> 구현을 생각하고 바꿨을 대 그 내부만 바뀌면 좋겠다. (내부에서만 바뀌고 외부에는 안 나가는 것이 좋음)

안 바뀌는데 왜 이렇게 복잡하게 했냐???? 왜 이렇게 했지? 이유가 있지 않을까;;
history를 들어야 이해되는 코드가 있음

결합도 측면에서 변경하기 더 쉽다.

##### 캡슐화란
 -> 변경 가능성이 높은 부분을 내부로 숨기는 추상화 기법, 설계에서 변하는 것이 무엇ㅇ인지 고민하고 변하는 개념을 캡슐화
변경될 수 있는 어떤 것이라도 숨김

타입 캡슐화
- 자주 변하는 객체의 타입을 추상화 뒤로 캡슐화, 타입이 바뀌더라도 클라이언트 코드가 바뀌지 않았으면 좋겠다.
데이터 캡슐화, 데이터가 바뀌더라도 밖으로 영향을 안 주고 싶다.

동일한 메시지에 응답하는 경우 해결하는 것이 다형성 (인터페이스 or 추상 클래스)

타입을 숨기기 위해서 타입 캡슐화하는 것이 아닌 구현을 재사용하기 위해서 사용하는 것이 잘못된 상속이다.
차라리 합성을 사용하는 것이 좋음!!!!!!!!!!!!!!!
(OCP)

의존성 역전 원칙(DIP) discountPolicy
상위 모듈과 하위 모듈 모두 추상화에 의존 - 타입이 변경될 때 적절하게 사용하고 싶을 때 쓰는 것이 좋다.


#### 요구사항 변경

N 개의 할인 정책
중복 할인이 적용 될 수 있음

코드를 보면서 중복할인을 허용하는 것을 이해해야 한다.
메시지만 보냈을 떄 동일한 응답만 준다면 변경할 수 없다.(LSP)
OverlappedDiscountPolicy (AmountDiscountPolicy, PercentDiscountPolicy)

DIP를 하면 내가 어떤 코드를 추가 했을 떄 의존하는 것이 없기 떄문에 안심하고 수정할 수 있다. (OCP)
확정에는 열려 있고 수정에는 닫혀 있다. 

복잡하고 끊임 없이 변하는 비즈니스 규칙을 구현해야 한다면 객체 모델을 사용하자 - Martin Fowler

결합도를 낮추기 위해서 중복으로 Dto를 만드는 것이 좋을 수 있다.
TradeOff

설계는 무엇이 변경되는 것인지 아는 것이 가장 중요하다.

(ISP) interface를 찢고 구현체에서 둘 다 영향을 받을 수 있기 때문에 찢는 것이 좋다.

참고 도서
applying uml, design patterns(gof, head first design pattern)
패턴을 활용한 리팩터링, 로버트 마틴(애자일 PPP, SOLID 이해하기 좋음)
단위 테스트
