입문자를 위한 객체지향 안내서 - 조영호 (2022-07-09)

- 발표주제 : 입문자를 위한 객체지향 안내서
- 발표시간 : 3시간(2시간 30분 강의/30분 질의응답)
- 발표내용(안)
  - 동일한 요구사항을 절차적인 코드와 객체지향 적인 코드로 작성
  - 두 가지 방식의 코드를 응집도, 결합도, 캡슐화 관점에서 비교
  - 코드의 비교를 통해 객체지향의 장점과 결합도, 캡슐화에 대한 개념 이해


#### 영화 예매 도메인

도메인 : 해결하고자 하는 영역 (범위)
도메인 모델 : 중요한 것들을 정리하고 추상화 한 것

- Movie
- Screening
- Discount Policy (Amount Discount Policy, Percent Discount Policy)
- Discount Condition (Sequence Condition, Period Sequence)

! 영화에 상영을 하면서 예매에 가격을 계산하는 것

절차적, 객체지향

결과가 중요한 것이 아니고 이런 사고를 하기 때문에 이런 결과가 나오는 것이 중요하다.

#### 절차적 (Procedural)
읽는 순서와 실행순서가 같음

Data와 Process를 분리할 때 그런 결과가 나옴

Data 중심으로 ERD 를 그림 -> Data와 동일한 Class를 만듬(상태를 관리할 수 있음)

> 캡슐화한다고 private으로 get/set을 만들지만 이것이 캡슐화를 보존하지 않음
> get set은 누가 쓸지 모르고 전역 데이터처럼 돌게 된다.

! type 체크를 하는 것이 있으면 절차 지향이라고 할 수 있음 사용하는 애가 판단해야함
! 객체는 스스로가 스마트함 자기가 무엇인지 알고 있음, 데이터는 바보임
! 절차적인 코드는 중앙 집중식 제어 스타일 (쓰는 곳이 한 곳에 몰려 있음) 

#### 객체지향 설계
읽는 순서와 실행순서가 다를 수 있음

확장이 쉽고, 유지 보수성이 좋다.
Object(Process, Data)

> 어떤 Context가 있는 상황에서 어떤 Class가 필요하지라는 것이 중요하다
> Process, Data를 같이 사용 Process를 먼저 생각 Data는 마지막에 정한다 
> (TDD라고 생각해도 된다.) Interface를 만들고 Implements를 만든다. 실패 -> 성공 계속함
> Runtime을 만들고 Compile로 와야한다 객체 관점에서 설계한 후 그것을 담을 수 있는 Class를 만든다.

영화를 예매하기위한 Context를 만들고 Data를 만든다.


- 애플리케이션의 요구사항 파악
- 애플리케이션의 요구사항을 시스템의 책임으로 변환
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 수 있는 적절한 객체 선택
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움 요청

CRC(Candidate 위, Responsible 왼, Collaborator 오)카드 캔트백

예매 생성에 필요한 정보의 전문가에게 할당
도메인 개념을 기반으로 정보의 전문가에게 할당 (개념적 차이가 적음 - 유비쿼터스 랭귀지)
가장 적합한 정보를 가진 객체

> 객체와 Data의 차이는???
> 정보는 어떻게해서 계산해줄 수 있음 (누가 가장 적합한가)

1. 예매한다 상영을 ->> 상영: Screening 이 예매를 한다. || (자기 자신을 예매하는 것이 가장 자연 스러움) 대부분의 사람이 납득, 공통의 이해를 만듬
    - 가격 정보가 필요함
2. 가격에 대한 정보: Movie 는 영화가 가장 잘 알고 있음, 영화에게 메시지를 보냄
3. 할인가격을 알아야함: DiscountPolicy
4. 할인조건을 알아야함: DiscountCondition

응집도가 떨어지는 클래스는? 메소드에 필요한 필드만 속성으로 넣기 때문에 응집도가 떨어진다.
클래스 크기가 작고 많아짐 (응집도, 결합도, 캡슐화에 좋아짐) 

패키지, 클래스를 나눔 명사를 일단 한정지을 수 있기 때문에 객체지향이 좋음
(서비스, 도메인으로 패키지를 나누면 찾기 힘듬, 패키지, 객체를 잘 나눠서 사용해야함, 절차지향적인 코드는 처음부터 다시 읽어야함)

위임식/분산식 제어 스타일이다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
의존성
trade off : parameter를 넘기는 경우 객체를 넘기는 경우
의존성 A가 B에게 의존한다. B가 변경이 되면 A도 변경 될 수 있음

의존성은 4가지 정도가 있다.
field, method parameter, local variable, return value

끊기 위한 방법은
1. 의존성을 끊는 것이 좋다.
2. 단방향이 좋고

의존성이 있을때 변경에 영향도가 크면 결합도가 높다 작으면 결합도가 낮다.

라이프 사이클이 같으면
aggregate
lifecycle constraint 가 비슷하면 양뱡향 의존성이 있을 수 있다고 생각함

만약 그것이 아니라면
parameter를 넘기는 것이 좋겠다. (2가지를 넣는 방법, 객체로 묶는 방법)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
















