# DDD

1부 동작하는 도메인 모델 만들기 - 도메인 주도 설계의 기본적인 목표 (도메인을 이용해서 작동하는 것을 만들기)
2부 모델 주도 설계의 기본 요소 - (도메인)모델 주도 설계, 모델과 소프트사이의 갭을 줄이기 위해
3부 더 심층적인 통찰력을 향한 리팩터링 - 
4부 전략적 설계 - 복잡한 시스템, 더 큰 조직, 외부 시스템 및 기존 시스템과의 상호작용에서 발생하는 상황


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

생산 계획이 있으면 재고 관리하고 했음
부품에 재고가 언제쯤 없어진다. 언제쯤 주문하는 것들을 정함

MOQ Minimum Order Quantity
LeadTime 등

기존에 하던 업무를 자동화해주는 것이였음

공장, 증권사, 현금 관리

왜 설계라는 말을 썼나 보며?
Eric Evans (Software Designer)

소프트웨어자체가 디자인이 됐다.
책이 나온 20년 전과 지금은 무엇이 다른가?

> 도메인 주도 설계라고 칭하는 하나의 철학이 나타났음

철학이라 이 책이 어렵다

MS
> Domain-Driven Design(DDD) is a collection of principles and patterns that help developers craft elegant object systems. 
> Properly applied it can lead to software abstractions called domain models. 
> These models encapsulate complex business logic, closing the gap between business reality and code.

반 버논
> DDD will help you to see how you should model software according to the unique business needs that your company has.

마틴 파울러
> Domain-Driven Design is an approach to software development that centers the development on programming a domain model that has a rich understanding of the processes and rules of a domain

모델링, DDD, UML, OOAD, 도메인 모델

DDD -> 도메인 모델(객체 지향 모델링)을 잘 만들자, 중요하다

도메인 모델 빌딩 블럭스

Bounded Context 가 틀어질 수 있으니 자주 모여서 continuous integration 해야함

DDD 한다.
도메인 모델 어디있음? 도메인 통합을 어떻게 하는 것인가?
이걸 대답 못하면 practice를 차용한 것이다.

도메인 모델링

도메인 : 해결하고자 하는 문제 영역
도메인 모델 : 특정 문제와 관련된 모든 주제의 개념 모델, 엔티티, 속성, 역할, 관계, 제약, 솔루션은 기술하지 않음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


## 1부 동작하는 도메인 모델 만들기

도메인 : 사용자가 프로그램을 사용하는 대상 영역
모델 : 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태 (단순화, 추상화)
도메인 모델 : 어떤 특정한 다이어그램이 아닌 다이어그램이 전달하고자 하는 아이디어 (중요하다고 생각하는 것을 선택하고 구조화시킨 결과물)
도메인 모델링 : 어떤 목적에 따라 제약에 구애받지 않고 현실을 표현하는 영화 제작에 가까움 (기본적인 UML 그리는 정도는 할 수 있어야 한다.)
[UML](https://creately.com/blog/diagrams/uml-diagram-types-examples/)
[GML](http://wiki.c2.com/?GalacticModelingLanguage)

#### 도메인 주도 설계에서의 모델의 유용성
1. 모델과 핵심 설계는 서로 영향을 주며 구체화된다. - 모델을 의미 있게 만들고 모델의 분석이 최종 산출물인 동작하는 프로그램에 적용되게끔 보장하는 것은 모델과 구현 간의 긴밀한 연결
2. 모델은 모든 팀 구성원이 사용하는 언어의 중추. - 모델과 구현이 긴밀하므로 개발자와 도메인 전문가가 의사소통하는데 별도의 번역 절차가 필요하지 않음
3. 모델은 지식의 정수만을 뽑아낸 것이다. - 모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식

#### 소프트웨어의 본질
소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있음

기술적으로 완벽하지 못하다고 영화의 본질이 사라진 예시가 있음

> 팀의 리더가 도메인의 중심이 되는 개념을 알고 있어야 해당 도메인의 심층적인 이해를 반영하는 모델 개발이 갈피를 잡지 못할 때 소프트웨어 프로젝트를 올바른 방향으로 되돌려 놓을 수 있다.

### 1장 지식 탐구

새로운 정보를 체계화하고 더 빠르게 배우게 하며, 무엇이 중요하고 중요하지 않은가를 더 잘 추측할 수 있게 해주며 PCB 예시 같은 엔지니어와 더 원할하게 의사소통하게 만들어줄 틀이 된다.

#### 효과적인 모델링의 요소

1. 모델과 구현의 연계 - 프로토타입을 토대로 본질적인 연결 고리를 만든다.
2. 모델을 기반으로 하는 언어 정제 - 누구라도 모델에서 바로 용어를 끄집어내어 모델의 구조와 일관되게 문장을 구성할 수 있게 된다.
3. 풍부한 지식이 담긴 모델 개발 - 모델은 복잡한 문제를 해결하는 데 필수불가결, 모델에는 다양한 지식이 포함돼 있다.
4. 모델의 정제 - 모델이 완정해지면서 중요한 개념이 더해지고, 중여하지 않다고 판면된 개념에 제거 됐다.
5. 브레인스토밍과 실험

#### 지식 탐구

도메인 전문가들은 자신이 알고 있는 지식의 정수만을 추출해내야 하므로 스스로 이해하는 바를 자주 정제함으로써 소프트웨어 프로젝트에서 요구하는 개념적 엄밀함을 이해하게 된다.
모델관 관계없는 것은 가려내고 모델을 더욱 유용한 형태로 고쳐 만든다.

#### 지속적인 학습
도메인 전문가에게서 모두 똑같이 지식을 얻고 의사소통 체계를 공유하며, 구현을 거쳐 피드백 고리를 완성하는 일을 모두 효과적으로 수행하는 지식 탐구 프로세스를 궤도에 올려야한다.

#### 풍부한 지식이 담긴 설계

Voyage - Cargo 예제

1. 코드가 복잡하면 개발자의 도움이 있더라도 업무 전문가가 코드를 읽고 규칙을 검증하지 못함
2. 해당 업무에 종사하지 않고 기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부시키기 어려움


1. 특정 부분이 계산에 불과한 것이 아닌 중요한 업무 규칙임을 알 수 있도록 표현한다.
2. 업무 전문가에게 그들이 이해할 수 있는 수준에서 기술적 산출물, 심지어 코드까지도 보여줄 수 있다.


### 심층 모델

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

대기업 전물 컨설팅 외주 업체들은 프로젝트가 폭포수 모델로 많이 진행 됨

업무 자동화를 하려면 BPR (Business process reengineering) - 회계사들이 했음?
BPR이 없이 자동화를 넣으면 회사 전체적 자동화가 어렵다.
-> IT consultant (enterprise -> software architecture) (대충하고 넘어감, 무엇을 설계했는지 모르게 됨)
-> UML, model 설계
-> SI 회사들이 개발 
(모델이 잘못 되었는데 변경 요구하는데 -> 변경책임을 개발자한테 넘김 -> 적당히 요구사항만 맞게함) (요구사항이 바뀌니 db, jsp만 바꿔서 함)

> 결국 도메인 전문가는 사용자, 모델링을 전문적으로 하는 사람들 전부 모여서 도메인 모델을 만들자 

!! 유비쿼터스 랭귀지 - 현업과 개발자의 언어를 맞춰가자

도메인 중요 로직이 무엇인지 알게된다.

그래서 모델을 어떻게 그리고 업데이트 할 것인가?
-> 이벤트스토밍이 나왔음

!!! 도메인 이벤트를 넣어서 아이디어의 중요 포인트를 찾아내는 것들이 추상화가 잘 되어 있다는 생각이 듬
!!! 이벤트 스토밍 - 워크샾 다 모여서함, 여기에만 집중할 수 있는 환경 (큰 회사는 TFT 하기도 함)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

### 2장 의사소통과 언어 사용

모델은 - 도메인에 대한 통찰력을 반영하는 용어와 관계로 표현된다.

프로젝트에서 사용하는 언어가 분열되면 심각한 문제가 발생
번역은 의사소통을 무디게 하고 지식 탐구를 빈약하게 함

언어의 변화는 도메인 모델의 변화로 인식

> 모델을 언어의 근간으로 사용하고 팀 내 모든 의사소통과 코드에서 해당 언어를 끊임없이 적용하는데 전념해야한다.
> 다이어그램과 문서, 말할 때 동일한 언어를 사용
> 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내는 데 촉각을 곤두세워야한다.


#### 크게 소리내어 모델링하기

시스템에 관해 이야기를 주고받을 때 모델을 사용하라. 모델의 요소와 상호작용을 이용하고 모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보라.
표현해야 할 것을 더 쉽게 말하는 방법을 찾아낸 다음 그렇나 새로운 아이디어를 다이어그램과 코드에 적용하라.

#### 문서와 다이어그램
설계의 생생한 세부사항은 코드에 담긴다.

#### 글로 쓴 설계 문서
문서는 코드와 말을 보완하는 역할을 해야한다.
문서는 코드가 이미 잘 하고 있는 것을 하려고 해서는 안 된다.
문서는 프로젝트 활동과 관련을 맺고 있어야 한다.


#### 설명을 위한 모델
하나의 모델이 구현, 설계, 의사소통의 기초가 돼야한다.

설명을 위한 모델에서는 특정 주제에 맞춰 훨씬 더 전달력이 높은 의사소통 방식을 만들어 낼 수 있다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

자기한테 익숙한 표현으로 쓰는 경우

핵심 도메인 모델을 중심에 두고 설계도 모델을 기반으로 하고 구현도 모델 기반으로하고
테스트까지 일관적으로 해야한다.

도메인 모델을 어떻게 표현할 것인지가 가장 큰 고민임
모델을 그려놓고 풀어나가는 것이 줄었다.

개발자와 전문가가 용어를 맞춰가는 과정 - 유비쿼터스 랭귀지

테이블 컬럼명이 각기 다르다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

### 3장 모델과 구현의 연계

소프트웨어 개발 프로젝트의 맥락에 한정해서 생각해봐도 모델은 다양한 형태로 나타나고 여러 역할을 수행한다. 도메인 주도 설계에서는 초기 분석 단계에 도움될 뿐 아니라
설계의 기반이 되는 모델이 필요하다.

> 코드와 그것의 기반이 되는 모델이 긴밀하게 연결되면 코드에 의미가 부여되고 모델과 코드가 서로 대응하게 된다.

설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확함도 의심스러워진다.
동시에 모델과 설계 긴으 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 치명적으로 동떨어지고, 그에 따라
각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.

도메인 모델을 설계에 밀접하게 연관시키는 원칙을 강제하면 가능한 각종 모델 가운데 좀더 유용한 것을 선택하는 또 하나의 기준이 만들어진다.
이를 위해서는 많은 고민이 필요하고 보통 수차례의 걸친 반복주기와 상당한 양의 리팩터링이 따르지만
관련성 있는 모델이 만들어진다.


#### 모델링 패러다임과 도구 지원

C는 MODEL-DRIVEN DESIGN 적용이 어려움

예제 - 절차적인 방식에서 모델 주도적인 방식으로

기계적인 설계 -> 파일이 형식이 다르게 된다면 처음부터 다시 작업을 해야할 것

모델 주도 설계 -> 가져오기/내보내기 로직은 간결한 서비스로 캡슐화한다.
> 각 서비스와 리포지터리는 단위 테스트가 가능하고, 핵심적인 도메인 로직을 테스트할 수 있다.

연산이 하나라면 스크립트 기반 접근법이 가장 적합할지 모르지만 현실은 20개 이상의 스크립트가 존재하므로
MODEL-DRIVEN DESIGN 은 쉽게 규모를 확장할 수 있고 제약조건을 포함할 수 있다.
-> 한 번에 나타나는 것이 아닌 도메인의 중요한 개념만 추출해서 간결하고 예리한 모델로 표현하려면 리펙터링과 지식 탐구의 과정을 반복해야한다.

#### 내부 드러내기

MODEL-DRIVEN DESIGN 에서는 오로지 하나의 모델을 다룰 것을 요구한다.

#### HANDS-ON MODELER
모든 팀원에게는 각기 전문화된 역할이 있지만 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MODEL-DRIVEN DESIGN과 상충

코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킨다.

> 모델에 기여하는 모든 기술자는 프로젝트 내에서 수행하는 일차적 역할과는 상관없이 코드를 접하는 데 어느 정도 시간을 투자해야만 한다.
> 코드를 변경하는 책임이 있는 모든 이들은 코드를 통해 모델을 표현하는 법을 반드시 배워야 한다. 모든 개발자는 모델에 관한 일정 수준의 토의에 깊이 관여해야 하고
> 도메인 전문가와도 접촉해야 한다. 다른 방식을 모델에 기여하는 사람들은 의식적으로 코드를 접하는 사람들과 UBIQUITOUS LANGUAGE를 토대로 모델의 아이디어를 나누는데 적극 참여해야한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

모델링 -> 설계 -> 구현
으로 하던 시기에는 모델링을 하고 도망갔음 갭이 크다

모델과 개발은 같이 가야한다. -> (패턴과 용어가 앞으로 나올 것)
설계와 구현이 같이간다.

모델과 디자인을 연결시켜야한다.

1장 모든 사람이 도메인 모델 만들기 참여
2장 모델 언어에 근간을 해라 - 유비쿼터스 랭귀지
3장 모델을 잘 만드는 이유는 모델을 실제와 코드까지 이어지게 한다.

DDD가 모든 개발에 적합한 것은 아니다

패러다임 - (명령형) 객체지향, 절차지향 | (선언형) 함수형 - (기술하다, 선언하다) html, xml | (논리형) 프로그래밍 프롤로그 prolog

2부에서는 각각 다르게 할 수 있지만 유용한 도구들에 대한 내용이 나온다.

모델 아키텍처와 코드는 같이감

> HANDS-ON MODELER 은 코드에 관심을 가져야하고
> 개발자는 도메인 모델에 관여해야한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

## 2부 모델 주도 설계의 기본 요소

표준 패턴들을 공유하면 설계에 체계가 생겨 팀 구성원이 각기 다른 구성원의 업무를 더욱 쉽게 이해할 수 있다.

### 4장 도메인의 격리

시스템에서 도메인과 관련이 적은 기능으로부터 도메인 객체를 분리할 필요가 있으며, 그렇게 해서 도메인 개념을 다른 소프트웨어 기술에만 관련된 개념과 혼동하거나,
또는 시스템이라는 하나의 큰 덩어리 안에서 도메인을 전혀 바라보지 못하는 문제를 방지할 수 있다.

도메인에 관련된 코드가 상당한 양의 도메인과 관련이 없는 다른 코드를 통해 널리 확산될 경우 도메인에 관련된 코드를 확인하고 추론하기가 힘들어진다.
기술과 로직이 모두 각 활동에 포함돼 있다면 프로그램을 매우 단순하게 유지해야하며, 그렇지 않으면 프로그램을 이해하기가 불가능해진다.

매우 복잡한 작업을 처리하는 소프트웨어를 만들 경우 관심사의 분리가 필요하며 이로써 격리된 상태에 있는 각 설계 요소에 집중할 수 있다.

계층화의 가치는 각 계층에서 컴퓨터 프로그램의 특정 측면만을 전문적으로 다룬다는 데 있다. 이러한 전문화를 토대로 각 측면에서는 더욱 응집력 있는 설계가 가능해지며,
이로써 설계를 훨씬 더 쉽게 이해할 수 있다.

하위 수준의 객체가 상위 수준의 객체와 소통해야 할 경우 콜백이나 옵저버 패턴처럼 계층 간에 관계를 맺어주는 아키텍처 패턴을 활용할 수 있다.


#### 아키텍처 프레임워크

가장 바람직한 아키텍처 프레임워크라면 도메인 개발자가 모델을 표현하는 것에만 집중하게 해서 복잡한 기술적 난제를 해결한다.

프레임 워크의 목적은 도메인 모델을 표현하고 해당 도메인 모델을 이용해 중요한 문제를 해결하는 구현을 만들어내는데 있다.

#### 도메인 계층은 모델이 살아가는 곳

SMART UI 는 안티 패턴으로 간주될 수 있음
장점
- 애플리케이션이 단순한 경우 생산성이 높고 효과가 즉각적으로 나타난다.
- 다소 능력이 부족한 개발자도 약간의 교육으로 이러한 방식으로 업무를 진행할 수 있다.
- 요구사항 분석 단계에서 결함이 발생하더라도 사용자에게 프로토타입을 배포한 후 요구에 맞게 제품을 변경해서 문제를 해결할 수 있다.
- 애플리케이션이 서로 분리되므로 규모가 작은 모듈의 납기 일정을 비교적 정확하게 계획할 수 있다. 부가적이고 간단한 작업만으로도 시스템을 확장하기가 수월할 수 있다.
- 관계형 데이터베이스와 잘 어울리고 데이터 수준의 통합이 가능하다.
- 4세대 언어 도구와 잘 어울린다.
- 애플리케이션을 인도했을 때 유지보수 프로그래머가 이해하지 못하는 부분을 신속하제 재 잡업할 수 있다. 이는 변경의 효과가 특정 UI에 국한되기 때문이다.

단점
- 데이터베이스를 이용하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않다.
- 행위를 재사용하지 않으며 업무 문제에 대한 추상화가 이뤄지지 않는다. 업무 규칭이 적용되는 연산마다 업무 규칭이 중복된다.
- 신속한 프로토타입 작성과 반복주기가 SMART UI가 지닌 태생적인 한계에 도달하게 된다. 추사황의 부재로 리팩터링의 여지가 제한되기 때문이다.
- 복잡성에 금방 압도되어 애플리케이션의 성장 경로가 순전히 부가적인 단순 응용으로만 향한다. 우아한 방법으로 더욱 풍부한 행위를 갖출 수 있는 방법은 없다.


아키텍처에서 응집력 있는 도메인 설계가 시스템의 다른 부분과 느슨하게 결합될 수 있게 도메인 관련 코드를 격리한다면 아마 그러한 아키텍처는 도메인 주도 설계를 지원할 수 있을 것이다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
boot를 쓰기 전에는

dispatcher servlet 같은 것을 기계적으로 넣었어야함

컨트롤러 전략을 무엇으로 할지 결정해야했다.

DB를 사용한다고하면 datasource도 직접 정의해야했음, datasource 빈 등록하고 커넥션 풀 라이브러리 설정함
JPA를 쓰면 entity manage factory 설정함
View 엔진도 결정해야함

-> db stored procedure 에서 로직 처리하는 것에 익숙했었음 (plsql)
db에서 제약조건 줘서 정합성 판단했었음

client (visual basic, power builder, 델파이) 윈도우에서 사용하는 비쥬얼 컴포넌트가 많이 지원 됐었음

미들웨어 중간에 서버를 두는 쪽으로 많이 흘러갔음

원티어 - 화면에 입력하면 바로 서버에감,
투티어 - 화면, DB,
쓰리티어 - 화면, 서버, DB (json, xml도 없어서 string 포멧 있었음)

jdbc 하면서 service에서 가져오는 코드가 있었음


!! 도메인에서 흩어진 것들을 모으고 침범하지 않도록 하자

배민, 쿠팡, 빗썸도 php 제로보드 붙여서 만듬

> active record 패턴 도메인에서 자기 자신을 save 할 수 있음
> transaction script 패턴 서비스 하나가 비즈니스 트랜직션을 다 담음

컨트롤러에 http를 서비스로 넘기지 않음

java agent 코드가 돌아다니면서 실행이 됨

스프링 2.0에서 aspecJ 를 이용해서 엔티티에서 infra structure 호출할 수 있도록 해야한다.

(콜백, 옵저버 패턴처럼 계층 간에 관계를 맺어주는 패턴을 사용할 수 있음)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ




### 5장 소프트웨어에서 표현되는 모델

모든 설계 관련 의사결정은 도메인에 부여된 통찰력을 바탕으로 내려야 한다는 사실을 알 수 있따. 기술적인 측정 수단으로 여겨지는 높은 응집도와 낮은 결합도라는
개념은 도메인 개념에도 적용할 수 있다.


#### 연관관계

모델 내의 모든 탐색 가능한 연관관계에 대해 그것과 동일한 특성을 지닌 매커니즘이 소프트웨어에도 있다.

연관관계를 좀더 쉽게 다루는 방법으로는 다음 세 가지가 있다.

1. 탐색 방향을 부여한다.
2. 한정자를 추가해서 사실상 다중성을 줄인다.
3. 중요하지 않은 연관관계를 제거한다.

다대다 연관관계의 탐색 방향을 제약하면 해당 연관관계는 사실상 훨씬 더 구현하기 쉬운 일대다 연관관계로 줄어든다.


#### ENTITY

어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 ENTITY라 한다.
ENTITY에는 모델링과 설계상의 특수한 고려사항이 포함돼 있다. ENTITY는 자신의 생명주기동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성은 유지해야 한다.
또한 사실상 ENTITY를 추적하려면 ENTITY에 식별성이 정의돼 있어야 한다. ENTITY의 클래스 정의와 책임, 속성, 연관관계는 ENTITY에 포함된 특정 속성보다
ENTITY의 정체성에 초점을 맞춰야 한다. ENTITY가 그렇게까지 급격하게 변경되지 않거나 생명주기가 복잡하지 않더라도 의미에 따라 ENTITY를 분류한다면 모델이
더욱 투명해지고 구현은 견고해질 것이다.


한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아라. 클래스 정의를 단순하게 하고 생명주기의 연속성과 식별성에 집중하라.
객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의하라. 객체의 속성으로 객체의 이치 여부를 판단하는 요구사항에 주의하라. 각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라.
이러한 연산은 객체에 유일함을 보장받는 기호를 덧붙여서 정의할 수 있을지도 모른다. 이 같은 식별 수단은 외부에서 가져오거나 시스템에서 자체적으로 만들어 내는 임의의 식별자일 수도 있지만,
모델에서 식별성을 구분하는 방법과 일치해야 한다. 모델은 동일하다는 것이 무슨 의미인지 정의해야 한다.


#### ENTITY 모델링

ENTITY의 속성이나 행위에 집중하기 보다는 ENTITY 별도로 분리돼 있을 때 자신의 책임을 가장 잘 수행한다.
ENTITY의 속성이나 행위에 집중하기보다는 ENTITY 객체를 해당 ENTITY 객체의 가장 본질적인 특징만으로 정의한다. 개념에 필수적인 행위만 추가하고 그 행위에 필요한
속성만 추가한다. 그 밖의 객체는 행위와 속성을 검토해서 가장 중심이 되는 ENTITY가 될 것이다. 또 어떤 것은 이어서 소개할 패턴인 VALUE OBJECT가 될 것이다.

#### 식별 연산의 설게

두 객체가 동일하다는 것이 무엇을 의미하는거? 라는 근원적 문제를 놓치기 쉬움

#### VALUE OBJECT

ENTITY의 식별성을 관리하는 일은 매우 중요하지만 그 밖의 객체에 식별성을 추가한다면 시스템의 성능이 저하되고, 분석 작업이 필요하며, 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워짐

#### VALUE OBJECT를 포함한 연관관계 설계

모델에 포함된 연관관계의 수가 더 적고 연관관계가 단순할수록 더 나은 모델이라 할 수 있음

VALUE OBJECT 간의 양방향 연관관계는 완전히 제거하도록 노력해야한다.

#### SERVICE

도메인의 개념 가운데 객체로는 모델에 어울리지 않는 것이 있다. 필요한 도메인 기능을 ENTITY나 VALUE에서 억지로 맡게 하면 모델에 기반을 둔 객체의 정의가 왜곡되거나,
또는 무의미하고 인위적으로 만들어진 객체가 추가될 것이다.

잘 만들어진 SERVICE는 다음 세 가지 특징이 있다.
1. 연산이 원래부터 ENTITY나 VALUE OBJECT의 일부를 구성하는 것이 아니라 도메인 개념관 관련돼 있다.
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
3. 연산이 상태를 갖지 않는다.

#### MODULE

MODULE로 쪼개지는 것은 코드가 아닌 개념이다. 

서로 독립적으로 이해하고 논리적으로 추론할 수 있다는 의미에서 낮은 결합도가 달성되도록 노력해야한다. 높은 수준의 도메인 개념에 따라 모델이 분리되고 그것에 대응되는
코드도 분리될 때까지 모델을 정제해야한다.
MODULE의 이름은 도메인에 통찰력을 줄 수 있어야한다.

#### 패러다임이 혼재할 때 MODEL-DRIVEN DESIGN 고수하기

- 구현 패러다임을 도메인에 억지로 맞추지 않는다.
- 유비쿼터스 언어에 의지한다.
- UML에 심취하지 않는다.
- 회의적이어야 한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
모델링과 구현에 다 사용할 수 있는 기본 요소

1. 예전 VALUE OBJECT : dto, 엔티티 빈(데이터 원격 JPA 같은 것)
value object 패턴 - 데이터를 한방에 가져오자

2. 마틴 파울러 요즘 VO : 계층 내부에서 사용되는 데이터
식별자 없고 불변 (재사용 가능함)

> Money datetime VO로 만들고 연산 기능을 집어 넣음

block chain 정보는 BigInteger

여기서 말한 서비스는 도메인 서비스임
엔티티나 VO로 나타낼 수 없는 것 Policy 같은 것
check or 결정

policy가 세 개가 있다고 fix 하는 방법이 없고


service에서 로직을 하는 경우도 있음
multiple bean 등록하고 di를 적절하게 해서
collection을 순회하면서 적절한 것 찾아내는 방법이 있다.

이런 설계를 하는 것이 실력이라고 할 수 있다.


서비스는 상태를 나타내지 않고 덩치가 커져서
hexagonal에서는 useCase가 많아짐

자바 9에 강력하게 외부에서 접근을 막는 모듈이 나옴 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

### 6장 도메인 객체의 생명주기

한 객체는 생성되어 다양한 상태를 거친 후 결국 저장되거나 삭제되면서 소멸한다.
다른 객체와 상호의전성을 맺는데 이때 갖가지 불변식이 적용된다.

1. 생명주기 동안의 무결성 유지하기
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기

팩터리를 이용해 복잡한 객체와 AGGREGATE를 재구성함으로써 그것들의 내부 구조를 캡슐화하는 것에 관해 살펴보겠다.


#### AGGREGATE

데이터베이스에서 Person 객체를 삭제한다고 해보면
이름, 생년월일, 작업 설명이 따른다. 하지만 주소는 다른 사람이 사용할 수 있음

동일한 객체에 여러 클라이언트가 동시에 접근하는 시스템에서 매우 심각해짐

> 모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다.
> 그 까닭은 단지 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다.
> 그렇다고 변경의 일관성을 보장하고자 신중 잠금 기법을 쓴다면 다수의 사용자가 서로 부적절하게 간섭해야 시스템이 사용할 수 없는 상태가 될 것이다.


문제의 근원은 모델에 경계가 정의돼 있지 않다는 데 있다.

여러 AGGREGATE에 걸쳐 존재하는 규칙이 언제나 최신 상태로 유지되는 것은 아니다. 다른 의존 관계는 이벤트 처리, 배치 처리, 혹은 다른 갱신 메커니즘을 토대로 특정 시간 내에 해결될 수 있다.
반면 한 AGGREGATE에 적용된 불변식은 각 트랜잭션이 완료될 때 이행될 것이다.


ENTITY와 VALUE OBJECT를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라.
한 ENTITY를 골라 AGGREGATE의 루트로 만들고 AGGREGATE 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게하라.

AGGREGATE는 업무 관행에 맞는 구매주문과 구매주문의 각 주문품목에 대한 소유권을 부여한다. 구매주문과 구매주문의 주문품목의 생성과 삭제는 자연스럽게 함께 묶이는
반면 품목의 생성과 삭제는 독립적으로 이뤄진다.


### FACTORY

어떤 객체나 전체 AGGREGATE를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 FACTORY가 캡슐화를 제공해준다.

어떤 객체를 생성하는 것이 그 자체로도 주요한 연산이 될 수 있지만 복잡한 조립 연산은 생성된 객체의 책임으로 어울리지 않는다.
이런 책임을 클라이언트에 두면 이해하기 힘든 볼품없는 설계가 만들어질 수 있다. 클라이언트에서 직접 필요로 하는 객체를 생성하면 클라이언트 설계가 지저분해지고 조립되는 객체나
AGGREGATE의 캡슐화를 위반하여, 클라이언트와 생성된 객체의 구현이 지나치게 결합된다.

복잡한 객체와 AGGREGATE의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라. 이 객체자체는 도메인 모델에서 아무런 책임도 맡지 않을 수도 있지만 여전히
도메인 설계의 일부를 구성한다. 모든 복잡한 객체 조립 과정을 캡슐화하는 동시에 클라이언트가 인스턴스화되는 객체의 구상 클래스를 참조할 필요가 없는 인터페이스를 제공하라.
전체 AGGREGATE를 하나의 단위로 생성해서 그것의 불변식이 이행되게 하라

#### FACTORY와 FACTORY의 위치 선정

FACTORY는 해당 FACTORY에서 만들어내는 객체와 매우 강하게 결합돼 있으므로 FACTORY는 자신의 생성물과 가장 밀접한 관계에 있는 객체이 있어야 한다.
구상 구현체나 생성 과정의 복잡성과 같은 것을 감춰야 한다면 비록 자연스로운 곳으로 보이지는 않더라도 전용 FACTORY 객체나 SERVICE를 만들어야 한다.

#### 생성자만으로 충분한 경우

- 클래스가 타입인 경우 클래스가 어떤 계층구조의 일부를 구성하지 않으며, 인터페이스를 구현하는 식으로 다형적으로 사용되지 않는 경우
- 클라이언트가 STRATEGY를 선택하는 한 방법으로서 구현체에 관심이 있는 경우
- 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
- 생성자가 복잡하지 않은 경우
- 공개 생성자가 FACTORY와 동일한 규칙을 반드시 준수해야 하는 경우 이때 해당 규칙은 생성된 객체의 모든 불변식을 충족하는 원자적인 연산이어야 한다.


#### 인터페이스 설계
- 각 연산은 원자적이어야 한다.
- FACTORY는 자신에게 전달된 인자와 결합될 것이다.

#### 불변식 로직의 위치

ENTITY가 생성되고 나면 해당 식별성은 불변이라면 FACTORY에게 불변식을 두는 것이 타당

### ENTITY FACTORY와 VALUE OBJECT FACTORY

#### 저장된 객체의 재구성

1. 재구성에 사용된 ENTITY FACTORY는 새로운 ID를 할당하지 않는다.
2. 객체를 재구성하는 FACTORY는 불변식 위반을 다른 방식으로 처리할 것이다.

### REPOSITORY

클라이언트는 이미 존재하는 도메인 객체의 참조를 획득하는 실용적인 수단을 필요로 한다.
인프라스트럭처에서 도메인 객체의 참조를 쉽게 획득할 수 있게 해준다면 클라이언트 측을 개발하는 개발자들이 좀더 탐색 가능한 연관관계를 추가해 모델을 엉망으로
만들어 버릴지도 모름.


- REPOSITORY는 영속화된 객체를 획득하고 해당 객체의 생명주기를 관리하기 위한 단순한 모델을 클라이언트에게 제시한다.
- REPOSITORY는 영속화 기술과 다수의 데이터베이트 전략, 또는 심지어 다수의 데이터 소스로부터 애플리케이션과 도메인 설계를 분리해준다.
- REPOSITORY는 객체 접근에 관한 설계 결정을 전해준다.
- REPOSITORY를 이용하면 테스트에서 사용할 가짜 구현을 손쉽게 대체할 수 있다.

#### REPOSITORY 구현

- 타입을 추상화한다.
- 클라이언트와 분리를 활용한다.


## 7장 언어의 사용(확장 예제)

#### 도메인 격리 : 응용 기능 소개
1. Tracking Query(추적 질의) : 특정 화물의 과거와 현재 처리 상태에 접근
2. Booking Application(예약 애플리케이션) : 새로운 Cargo를 등록하고 등록된 화물 처리를 준비
3. Incident Logging Application(사건 기록 애플리케이션) : 각 Cargo의 처리 내역을 기록 (Tracking Query로 찾은 정보를 제공)

#### ENTITY와 VALUE OBJECT의 구분
- Customer
- Cargo
- Handling Event와 Carrier Movement
- Location
- Delivery History
- Delivery Specification

##### 역할과 그 밖의 속성
역할은 그것이 한정하는 연관관계에 관한 사항을 전해주지만 이력이나 연속성을 지니고 있지는 않다. 따라서 역할은 VALUE OBJECT이며,
서로 다른 VALUE OBJECT이며, 서로 다른 Cargo/Customer로 구성된 연관관계 사이에서 공유할 수 있다.

시간/날짜나 이름과 같은 그 밖의 속성은 VALUE OBJECT다.

#### 해운 도메인의 연관관계 설계
양방향 연관관계는 설꼐에서 문제를 일으킬 수 있다. 또한 탐색 방향은 종종 통찰력을 포착해서 도메인에 반영함으로써
모델 자체를 심층적으로 만들기도 한다.

순환 참조는 논리적으로 여러 도메인에 존재하며 간혹 설계에도 필요하지만 순환 참조를 유지하는 데는 신중을 기해야 한다.


#### AGGREGATE의 경계

Custome와 Location Carrier Movement는 자체적인 식별성을 지니고 여러 Cargo 사이에서 공유되므로 그것들은 자체적인 AGGREGATE의 루트가 되어야 한다.

#### REPOSITORY의 선정
AGGREGATE의 루트인 ENTITY가 5개 있으므로 고려해야 할 사항을 여기에 맞게 한정할 수 있다.

#### 시나리오 연습
화물의 목적지 변경, 반복 업무

### 객체 생성
#### Cargo에 대한 FACTORY와 생성자
#### HandlingEvent 추가


#### 리팩터링할 시간: Cargo AGGREGATE의 설계 대안



## 제 3부 더 심층적인 통찰력을 향한 리팩터링

1. 정교한 도메인 모델은 만들 수 있으며, 노력을 들일 만한 가치가 있다.
2. 해당 도메인을 학습하는 개발자와 도메인 전문가의 긴밀한 참여와 반복적인 리팩터링 과정 없이 유용한 모델을 개발하기란 쉽지 않다.
3. 유용한 모델을 효과적으로 구현하고 사용하려면 정교한 설계 기술이 필요할지도 모른다.


#### 리팩터링 수준

리팩터링이란 소프트웨어의 기능을 수정하지 않고 설계를 다시 하는 것을 의미한다.
자동화된 단위 테스트 스위트가 구비돼 있따면 비교적 안전하게 리팩터링을 수행할 수 있다.

시스템의 생존력에 가장 큰 영향을 미치는 리팩터링은 도메인에 대한 새로운 통찰력을 얻었을 때 수행하거나 코드를 사용해서 모델이 표현하고자 하는 바를 명확하게 드러내고자 수행하는 경우다.
더 통찰력을 갖추기 위한 리팩터링

#### 심층모델

심층 모델이란 도메인의 피상적인 측면은 배제하고 도메인 전문가의 주요 관심사와 가장 적절한 지식을 알기 쉽게 표현하는 모델이다. 이 정의가 추상화를 의미하는 것은 아니다.
도메인과 조화를 이루는 모델에서는 융통성, 단순함, 설명력을 얻을 수 있따.

#### 심층 모델/유연한 설계

MODEL-DRIVEN DESIGN을 지탱하는 두 개의 축이 있다.
심층 모델은 설계에 표현력을 부여한다. 그와 동시에 개발자가 여러 가지 시도를 할 수 있을 정도로 설계가 유연하고 개발자가 무슨 일이 일어나고 있는지 파악할 수 있을 만큼
설계가 명확하다면 설계는 모델의 발견 과정에 통찰력을 제공할 수 있다. 이런 피드백 고리의 한 측면은 필수 불가결한 것이라고 할 수 있는데, 우리가 찾고 있는 모델이 단순히
훌륭한 아이디어의 집합이 아니라 구축하게 될 시스템의 기반이 되기 때문이다.






