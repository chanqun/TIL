# 우아한객체지향

[우아한테크세미나](https://www.youtube.com/watch?v=dJ5C4qRqAgA)

#### Dependency(의존성)

A -> B 
: A가 B에 의존한다. (변경에 의한 영향은 반대)


#### 클래스 의존성의 종류

- Association
- Dependency
- Inheritance
- Realization

#### 패키지 의존성

패키지에 포함된 클래스 사이의 의존성



#### !!! 양방향 의존성을 피하라

1. Bi-Directional -> 싱크 맞출때 많은 버그가 발생한다.   :  Uni-Direction
2. One-To-Many   :  Many-To-One
3. 의존성이 없으면 제거
4. 패키지 사이의 의존성 사이클을 제거

설계의 원칙 : 패키지가 싸이클이 온다는 것은 하나의 패키지라고 보면 된다.



관계의 방향 = 협력의 방향 = 의존성의 방향
관계의 종류 결정하기

- 연간관계 - runtime객체들이 어떻게 협력할 것인지 확인한다. (협력을 위해 필요한 영구적인 탐색 구조)
  빈번한 이동

  - 탐색가능성(navigability) 어떤 객체(Order)가 있는데 이것을 알면 다른 곳(OrderLineItem)을 찾아갈 수 있다.
    (두 객체 사이에 협력이 필요하고 두 객체의 관계가 영구적이라면 연관관계를 이용해 탐색 경로 구현)

  - 객체 참조를 이용한 연관관계 구현이 가능하다. 다른 다양한 방법도 있다.
    

- 의존관계 - 협력을 위해 일시적으로 필요한 의존성 (파라미터, 리턴타입, 지역변수)

  

#### 설계 개선하기

일단 짜고 dependency를 보고 설계를 개선한다.
dependency를 먼저 그려보자 package를 잘못나눴는지 확인

두 가지 문제

- 객체 참조로 인한 문제점

  - option과 shop을 계속 참조

    - 중간 객체를 이용한 의존성 사이클 끊기 - OptionGroup, Option

      개발자의 추상화란 - 잘 변화하지 않는 것이다. 필요한 것이 추상적으로 존재하는 것

- 연관관계 다시 살펴보기

  객체 참조로 구현한 연관관계의 문제점
  성능 문제 - 어디까지 조회할 것인가? 계속 참조를 한다. lazy loading
  수정 시 도메인 규칙을 함께 적용할 경계는
  이슈 : Order의 상태를 변경할 때 연관된 도메인 규칙을 함께 함께 적용해야하는 객체의 범위는?
             = 트랜잭션 경계는 어디까지인가?

  트랜잭션 경합으로 인한 성능 저하!!!!!!



#### 객체참조가 꼭 필요할까?

객체 참조의 문제점 - Everything is connected
객체 참조는 결합도가 가장 높은 의존성 - 필요한 경우에는 객체 참조를 끊는다.
Order를 알면 Shop으로 탐색가능하다.
Repository를 통한 탐색(약한 결합도)

비즈니스는 단방향이 가능하지만 admin기능이나 조회기능이 추가되면 양방향 관계가 계속 생긴다!



#### 어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?

간단한 규칙: 

- 함께 생성되고 함께 삭제되는 객체들은 묶는다.
- 도메인 제약사항을 공유하는 객체들은 함께 묶는다.
- 가능하면 분리한다.

경계 밖의 객체는 ID를 이용해 접근

객체를 끊으면 객체 단위로 transaction을 묶어주면 된다.

1. 
   이렇게 되면 참조하던 객체로 인해 compile error가 된다.

   객체를 참조하는 로직을 일단 Validation logic 객체에 모아서 해결했다.
   -> 낮은 응집도의 객체가 높아졌다.

   때로는 절차지향이 객체지향보다 좋다!

2. 도메인 로직의 순차적 실행으로 인해 컴파일 오류가 난다.
   - 절차지향 로직으로 해결
   - 도메인 이벤트 퍼블리싱

사이클 발생시 - 인터페이스를 이용해서 의존성 역전하면된다.

패키지를 분리 - Event Handler에서 Shop과 Billing을 분리 dependency cycle이 안 돌게 해결하였음



==> 의존성에 따라 시스템을 진화시켜라