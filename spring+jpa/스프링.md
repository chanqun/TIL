## 스프링 기본

WAS -> Dispatcher Servlet -> (Pre Handler, Handler Adapter - Controller, PostHandler) -> afterCompletion -> WAS

- 클라이언트의 요청을 디스패처 서블릿이 받음
- 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음
- 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함
- 핸들러 어댑터가 컨트롤러로 요청을 위임함
- 비지니스 로직을 처리함
- 컨트롤러가 반환값을 반환함
- 핸들러 어댑터가 반환값을 처리함
- 서버의 응답을 클라이언트로 반환함

![dispatcher-servlet.png](../image/dispatcher-servlet.png)

![filter.png](../image/filter.png)


### 서블릿, 서블릿 필터


로그인 서블릿 필터 제한
```java
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 //로그인 사용자
HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출X) //비 로그인 사용자
```
필터에서 적절하지 않은 요청이라고 판단하기 좋음

> ApplicationFilter는 등록해두면 재귀적으로 작동함 (coroutine같이)

> 필터(Filter)는 서블릿이 제공하는 기술이므로 서블릿 컨테이너에 의해 생성되며 서블릿 컨테이너에 등록이 된다. 그렇기 때문에 스프링의 빈으로 등록도 불가능했으며, 빈을 주입받을 수 없었다.
> 하지만 필터에서도 DI와 같은 스프링 기술을 필요로 하는 상황이 발생하면서, 스프링 개발자는 필터도 스프링 빈을 주입받을 수 있도록 대안을 마련하였는데, 그것이 바로 DelegatingFilterProxy이다. 



### 스프링 인터셉터

- 스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출 된다.
- 스프링 인터셉터는 스프링 MVC가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다. 스프링 MVC의 시작점이 디스패처 서블릿이라고 생각해보면 이해가 될 것이다.
- 스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할 수 있다.


HandlerInterceptor (request, response, handler)

- 서블릿 필터의 경우 단순하게 doFilter() 하나만 제공된다. 인터셉터는 컨트롤러 호출 전( preHandle ), 호출 후( postHandle ), 요청 완료 이후( afterCompletion )와 같이 단계적으로 잘 세분화 되어 있다.
- 서블릿 필터의 경우 단순히 request , response 만 제공했지만, 인터셉터는 어떤 컨트롤러( handler )가 호출되는지 호출 정보도 받을 수 있다. 그리고 어떤 modelAndView 가 반환되는지 응답 정보도 받을 수 있다.

[로깅 interceptor, aop ?](https://velog.io/@miot2j/Spring-Filter-Interceptor-AOP-%EC%B0%A8%EC%9D%B4-%EB%B0%8F-AOP%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-Logging%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%9C-%EC%9D%B4%EC%9C%A0)


### HandlerMethodArgumentResolver

```kotlin
@Retention(value = AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.VALUE_PARAMETER)
annotation class LogInUser

class LoginArgumentResolver(
    private val userRepository: UserRepository
) : HandlerMethodArgumentResolver {
    override fun supportsParameter(methodParameter: MethodParameter): Boolean {
        return methodParameter.getParameterAnnotation(LogInUser::class.java) != null
    }

    override fun resolveArgument(
        parameter: MethodParameter, mavContainer: ModelAndViewContainer?,
        webRequest: NativeWebRequest, binderFactory: WebDataBinderFactory?
    ): Any {
        return userRepository.findByIdOrThrow(CoinheimContext.userId())
    }
}

```

### converter

```java
package org.springframework.core.convert.converter;

public interface Converter<S, T> {
    T convert(S source);
}
```


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

## 스프링 고급

### thread local
ThreadLocal<UserInfo> local = ThreadLocal<>(); 

### proxy - 대리자

Client -> ServerInterface
            ^(proxy)   ^(server)
proxy 를 적용해도 실제 서버처럼 작동해야한다.

- 접근 제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연 로딩
- 부가 기능 추가
- 프록시 체인


### 동적 프록시 기술

자바가 기본으로 제공하는 jdk 동적 프록시 기술이나 CGLIB 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어낼 수 있다.
리플랙션 기술을 사용하여 클래스 메서드의 메타정보를 동적으로 획득하고 코드도 동적으로 호출할 수 있다.
(람다를 사용하면 공통화 가능하긴함, 내부클래스는 $)

```java
void test() throws Exception {
    Class classHello = Class.forName("Hello");

    Hello target = new Hello();

    Method methodHello = classHello.getMethod("callA");
    dynamicCall(methodHello, tartget)
}

private void dynamicCall(Method method, Object target) throws Exception {
    log.info("start");
    Object result = method.invoke(target);
    log.info("result: {}", result);
}
```
-> 클래스나 메소드 정보를 동적으로 변경할 수 있음 : 런타임시 동작하기 때문에 컴파일시 오류를 잡기 어려움

자바 프록시는 interface가 있어야함 - invocationHandler

### CGLIB - 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리

MethodInterceptor - 성능상 methodProxy 쓰면 좋음
```java
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(대상 class);
enhancer.serCallback(interceptor);

enhancer.create(); // 프록시 생성
```

final 붙으면 상속 불가능하기 때문에 CGLIB 예외 발생

### 스프링 프록시
InvocationHandler, MethodInterceptor 를 중복 없이 사용하려고 할때

ProxyFactory 인터페이스 있으면 jdk 동적 프록시 구체 클래스만 있으면 cglib 프록시

프록시 팩토리 사용하면 Advice(로직)를 호출하는 전용 InvocationHandler, MethodInterceptor를 내부에서 사용한다.
Pointcut이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.

> invocation.proceed() 를 호출하면 target클래스 호출하고 결과 받음

- 포인트컷 : 어디에 부가 기능을 적용하거나 하지 않을지 필터링 한다.
- 어드바이스 : 부가 기능을 정의한다.
- 어드바이저 : 포인트컷 + 어드바이스

하나의 target 에 여러 AOP가 동시에 적용되어도, 스프링의 AOP는 target 마다 하나의 프록시만 생성한다.


### 빈 후처리기

PostProcessor
빈 후처리기를 이용하면 컴포넌스 스캔을 사용하는 빈까지 프록시를 적용할 수 있다.

ㅡㅡ
AnnotationAwareAspectJAutoProxyCreator

어드바이저만 빈 등록하면 됨

AspectJExpressionPointcut

### @Aspect AOP

@Aspect, @Around, 메소드는 advice, joinPoint.proceed 하면 됨
어드바이저 캐싱도 함

![proxy.png](../image/proxy.png)

### 스프링 AOP
애스펙트를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP
AOP는 OOP를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 나왔음

핵심 기능 - 해당 객체가 제공하는 고유의 기능
부가 기능 - 핵심 기능을 보조하기 위해 제공되는 기능 (로그 추적 로직, 트랜잭션 기능)

AOP의 대표적인 구현으로 AspectJ 프레임워크

### AOP 적용하는 법

컴피일 시점 - 위빙 
클래스 로딩 시점 - jvm 저장하기 전에 java instrumentation (모니터링 툴들이 이런식으로 java -javaagent) 로드 조작기를 지정해줘야함
런타임 시점(프록시) - 스프링 같은 컨테이너의 도움을 받음

조인 포인트 - AOP 적용할 수 있는 모든 지점, 스프링은 메소드를 호출해야 사용할 수 있음
포인트 컷 - 어드바이스가 적용될 위치
타겟 - 어드바이스를 받는 객체
어드바이스 - 부가기능
애스팩트 - 어드바이스 + 포인트컷을 모듈화한 것
위빙 - 결정한 타겟 조인 포인트에 어드바이스를 적용하는 것
AOP프록시 - jdk 동적 프록시 또는 CGLIB 프록시

