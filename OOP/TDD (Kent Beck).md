## 테스트 주도 개발

clean code that works

- 예측 가능한 개발 방법이다. 끊임없이 발생할 버그에 대해 걱정하지 않고, 일이 언제 마무리될지 알 수 있다.
- 코드가 가르쳐주는 모든 교훈을 학습할 기회를 갖게 된다. 처음 생각나는 대로 후딱 완료해 버리면 두 번째 것, 더 나은 것에 대해 생각할 기회를 잃게 된다.
- 당신이 만든 소프트웨어는 사용자의 삶을 향상시켜 준다.
- 동료들이 당신을 존경할 수 있게 해주며, 당신 또한 동료들을 존경할 수 있게 된다.
- 작성하는 동안 기분이 좋다.


1. 빨강 - 실패하는 작은 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다.
2. 초록 - 빨리 테스트가 통과하게끔 만든다. 이를 위해 어떤 죄악을 저질러도 좋다.
3. 리팩토링 - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다.

순수하게 TDD로만 풀어낼 수는 없는 프로그래밍 작업도 있다. 동시성

와이캐시 달러에서 화폐를 추가 PolyCurrency 추가 후 테스트 코드를 추가하여 성공하는지 확인

- 방법 -> 워드와 와이캐시 팀은 설계를 조금씩 성장시키는 지속적 경험이 필요했음
- 동기 -> 워드와 그의 팀은 와이캐시를 다중 통화로 만드는 것의 비즈니스적 중요성을 분명히 이해, 외적으로 불가능해 보이는 작업을 시작할 용기가 있어야 했음
- 기회 -> 포괄적이고 자신감을 만들어 내는 테스트들, 잘 리팩토링된 프로그램, 설계 결정을 분리할 수 있는 프로그래밍 언어 등의 조합을 통해 에러의 요인이 거의 없었고, 설사 있더라도 에러를 손쉽게 파악할 수
  있었다.

- 어떤 코드건 작성하기 전에 실패하는 자동화된 테스트들 작성
- 중복을 제거

### 1부 화폐 예제

TDD 리듬

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

#### 1장. 다중 통화를 지원하는 Money 객체

- 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
- 어떤 금액을 어떤 수에 곱한 금액을 결과로 얻을 수 있어야한다.

테스트를 실패하기 위한 최소한의 작업만 진행

의존성과 중복 - 의존성은 소프트웨어 개발의 모든 부분에서 핵심적인 문제 벤더가 제공하는 세세한 기능들을 코드 여기저기에서 사용한다면 중복이 많다면 중복된 로직을 하나로 끄집어내는 객체를 이용하는 것이 좋다.

- 우리가 알고 있는 작업해야 할 테스트 목록을 만들기
- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현
- 스텁 구현을 통해 테스트를 컴파일
- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화
- 새로운 할일들을 한번에 처리하는 대한 할일 목록에 추가

#### 2장 타락한 객체

1. 테스트를 작성
2. 실행 가능하게 만듬
3. 올바르게 만듬

작동하는 깔끔한 코드를 만들어야한다.

분할 정복으로 - 작동하는 -> 깔끔한 코드로 만듬

#### 3장 모두를 위한 평등

값 객체 패턴 - 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다.

삼각측량을 이용

#### 4장 프라이버시

```java
public void testMultiPlication() {
        Dollar five = new Dollar(5);
        assertEquals(new Dollar(10),five.times(2))
        assertEquals(new Dollar(15),five.times(3))
}
```

테스트를 고치니 amount는 private 로 변경되도 괜찮다.

- 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용
- 두 테스트가 동시에 실패하면 망한다는 점을 인식
- 위험 요소가 있음에도 진행
- 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 이용


#### 5장 솔직히 말하자면
Franc 만들기

#### 6장 돌아온 모두를 위한 평등

리팩토링하면서 실수했는데도 불구하고 테스트가 여전히 통과한다면 있으면 좋을 것 같은 테스트를 추가한다.

- 공통된 코드를 Dollar에서 Money로 옮김
- Franc도 Money하위 클래스로 만듬
- 불필요한 equals() 구현 일치

#### 7장 사과와 오렌지

#### 8장 객체 만들기
Money 에 Dollar를 반환하는 팩토리 메소드를 도입할 수 있음

- 동일한 메서드의 두 변이형 메서드 서명부를 통일시킴으로써 중복 제거
- 최소한 메서드 선언부만이라도 공통 상위 클래스로 옮김
- 팩토리 메서드를 도입하여 테스트 코드에서 콘크리트 하위 클래스의 존재 사실을 분리
- 하위 클래스가 사라지면 몇몇 테스트는 불필요한 여분의 것이 된다

#### 9장 우리가 사는 시간

TDD란 조종해나가는 과정
동일한 생성자를 만들고 상위 클래스로 올렸다.

#### 10장 흥미로운 시간

- times()를 일치시키기 위해 그 메서드들이 호출하는 다른 메서드들을 인라인시킨 후 상수를 변수로 바꿈
- Franc 대신 Money를 반환하는 변경을 시도한 뒤 잘 작동하는지 테스트
  (Franc가 상위에 오는 것이 좋은지 Money가 오는 것이 좋은지 컴파일러와 테스트를 통해 알 수 있었다.)

  
#### 11장 모든 악의 근원

변경하기 위해 충분한 테스트 코드가 있는지 검증
- 하위 클래스의 속을 들어내는 걸 완료하고, 하위 클래스를 삭제
- 기존의 소스 구조에서는 필요했지만 새로운 구조에서는 필요 없게 된 테스트를 제거


#### 12장 드디어, 더하기

- 큰 테스트를 작은 테스트로 줄여서 발전을 나타낼 수 있도록 했다.
- 우리에게 필요한 계산에 대한 가능한 메타포들을 신중히 생각해봤다.
- 새 메타포에 기반하여 기존의 테스트를 재작성
- 테스트를 빠르게 컴파일
- 테스트를 실행
- 진짜 구현을 만들기 위해 필요한 리팩토링을 기대

#### 13장 진짜로 만들기

Bank.reduce는 Sum을 받는데 통화가 같다면 더함

- 모든 중복이 제거되기 전까지는 테스트를 통과한 것으로 치지 않음
- 구현하기 위해 역방향이 아닌 순방향 작업
- 앞으로 필요할 것으로 예상되는 객체의 생성을 강요하기 위한 테스트를 작성
- 빠른 속도로고 구현
- 명시적인 클래스 검사를 제거하기 위해 다형성 사용


#### 14장 바꾸기

- 별도의 테스트 없이 private helper 클래스 만듬
- 리팩토링 실수를 했고 문제를 분리하기 위해 또 하나의 테스트를 작성

#### 15장 서로 다른 통화 더하기
- 원하는 테스트를 작성하고, 한 단계에 달성할 수 있도록 뒤로 물렀다
- 좀더 추상적인 선언을 통해 가지에서 뿌리로 일반화
- 변경 후, 그 영향을 받은 다른 부분들을 변경하기 위해 컴파일러의 지시르 따름

#### 16장 드디어 추상화

- 미래에 코드를 읽을 다른 사람들을 염두에 둔 테스트를 작성
- TDD와 현재 개발 스타일을 비교해 볼 수 있는 실험 방법을 제시
- 또 한 번 선언부에 대한 수정이 시스템 나머지 부분으로 번졌고, 문제를 고치기 위해 컴파일러의 조언을 따름

#### 17장 Money 회고

- 다음에 할일은 무엇인가
중복, 린트, 검토
- 메타포 - 설계 구조에 미치는 메타포의 엄청난 영향
- JUnit 사용도 - 언제 테스트를 실행했으며, JUnit을 어떻게 사용해 왔는가
- 코드 메트릭스 - 결과 코드의 수치화
- 프로세스 - 빨강/초록/리팩토링 순서에 대해 이야기했는데, 각 단계에서 얼마 만큼 작업해야 하는가
- 테스트의 질 - 전통적인 테스트 메트릭스에 TDD 테스트가 어떻게 필적할 수 있는가

최종 검토
- 테스트를 확실히 돌아가게 만드는 세 가지 접근법: 가짜로 구현하기, 삼각측량법, 명백하게 구현하기
- 설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복을 제거하기
- 길이 미끄러우면 속도를 줄이고 상황이 좋은면 속도를 높이는 식으로 테스트 사이의 간격을 조절할 수 있는 능력

### 2부

#### 18장 xUnit으로 가는 첫걸음

> 테스트 메서드 호출하기
> 먼저 setUp 호출하기
> 나중에 tearDown 호출하기
> 테스트 메서드가 실패하더라도 tearDown 호출하기
> 여러 개의 테스트 실행하기
> 수집된 결과를 출력하기

```python
class TestCaseTest(TsetCase):
    def testRunning(self):
        test = WasRun("testMethod")
        assert(not test.wasRun)
        test.run()
        assert(test.wasRun)
        
TestCaseTest("testRunning").run()
```

- 자기 과신에 차서 몇 번의 잘못된 출발을 한 후, 아주 자그마한 단계로 시작하는 법을 알아냈다.
- 일단 하드코딩을 한 다음에 상수를 변수로 대체하여 일반성을 이끌어 내는 방식으로 기능을 구현했다.
- 플러거블 셀렉터를 사용했다. 플러거블 셀렉터는 정적 코드 분석을 어렵게 만들기 때문에 앞으로 최소 4개월 안에는 사용하지 않기로 약속하자.
- 테스트 프레임워크를 작은 단계로만 부트스트랩했다.

#### 19장 테이블 차리기
3A

1. 준비 - 객체를 생성한다.
2. 행동 - 어떤 자극을 준다.
3. 확인 - 결과를 검사한다.

- 성능 - 우린 테스트가 될 수 있는 한 빨리 실행되길 원한다. 여러 테스트에서 같은 객체를 사용한다면, 객체 하나만 생성해서 모든 테스트가 이 객체를 쓰게 할 수 있을 것이다.
- 격리 - 우린 한 테스트에서의 성공이나 실패가 다른 테스트에 영향을 주지 않기를 원한다. 만약 테스트들이 객체를 공유하는 상태에서 하나의 테스트가 공유 객체의 상태를 변경한다면 다음 테스트의 결과에 영향을 미칠 가능성이 있다.

#### 20장 뒷정리하기

- 플래그에서 로그로 테스트 전략을 구조 조정
- 새로운 로그 기능을 이용하여 tearDown()을 테스트하고 구현
- 문제를 발견했는데 뒤로 돌아가는 대신 과감히 수정


#### 21장 셈하기
수집한 결과 출력하기
#### 22장 실패 처리하기
실패한 테스트 보고하기
#### 23장 얼마나 달콤한지
테스트 여러 개 실행하기

#### 24장 xUnit 회고


### 3부 테스트 주도 개발의 패턴

#### 25장 테스트 주도 개발 패턴

- 자동화된 테스트를 만들어라
- 격리된 테스트 
  - 테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자, 어마어마한 양의 종이더미가 반드시 어마어마한 양의 문제를 의미하는 것은 아님 
- 테스트 목록을 모두 적어둘 것, 작업을 끝내기 전에 반드시 해야할 리팩토링 목록을 적는다.
- 테스트 대상이 되는 코드를 작성하기 직전에 작성한다.
- 단언 부터 시작하라
- 테스트 데이터, 명백한 데이터

#### 26장 빨간 막대 패턴
- 시작 테스트
- 설명 테스트
- 학습 테스트
- 회귀 테스트 : 시스템 장애로 인하여 실패하는 테스트
- 다시하기
- 싸구려 책상, 좋은 의자

#### 27장 테스팅 패턴

- 자식 테스트
- 모의 객체
  - 비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트
- 셀프 션트 
- 로그 문자, 이벤트 통보가 원하는 순서대로 발생하는지 확인할 때
- 크래시 테스트 더, 테스트 원하는 적절한 메서드만이 오류를 발생시키게끔 하기위해 사용
- 깨진 테스트, 혼자 할때는 마지막 테스트를 깨지게 한 채로 마무리하는 것이 좋다.
- 깨끗한 체크인, 팀프로그래밍은 모든 테스트가 성공한 상태

#### 28장 초록 막대 패턴
- 가짜로 구현하기 : 상수를 반환하게 하고 단계적으로 변수를 사용
  - 심리학적, 범위 조절 -> 하나의 구체적인 예에서 시작해서 일반화하게 되면 쓰잘데기 없는 고민으로 때 이르게 혼동하는 일을 예방할 수 있다.
- 삼각측량
  - 어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대해 감잡기 어려울 때 삼각측량을 사용
- 명백한 구현
- 하나에서 여럿으로 -> 나중에 컬렉션 적용

#### 29장 xUnit 패턴
- 단언
- 픽스처, 외부 픽스처
- 예외 테스트, 전체 테스트

#### 30장 디자인 패턴
- 커맨드, 값 객체, 널 객체, 템플릿 메소드, 플러거블 객체, 플러거블 셀렉터, 팩토리 메서드, 임포스터, 컴포지트, 수집 매개 변수
- 커맨드 : 메시지 보내기를 사용하라.
- 팩터리 메서드 : 유연함이 필요할 때에는 팩토리 메서드를 사용

#### 31장 리팩토링
- 차이점 일치시키기
- 변화 격리하기 (메서드, 객체 추출하기)
- 데이터 이주시키기

#### 32장 TDD 마스터하기


