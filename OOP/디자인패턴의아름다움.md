# 디자인 패턴의 아름다움

객체지향 프로그래밍 패러다임, 설계 원칙, 코딩 규칙, 리팩터링 기술, 디자인 패턴

## chapter 1 개요

### 1.1 코드 설계를 배우는 이유

코드 설계에 대한 지식은 확장성과 가독성이 높아 유지 보수가 용이한 고품질의 코드를 작성할 때 필요

### 1.2 코드 품질 평가 방법
유지 보수성, 가독성, 확장성, 유연성, 간결성, 재사용성, 테스트 용이성

### 1.3 고품질 코드를 작성하는 방법
객체지향, 설계 원칙, 디자인 패턴(생성, 구조, 행동), 코딩 규칙, 리팩터링 기법

### 1.4 과도한 설계를 피하는 방법
원래 의도는 결국 우리가 그 일을 하는 이유를 의미. 제품이 몇 번이고 업데이트되고, 몇 번이고 방향을 바꿔도 원래 의도는 바뀌지 않는 것이 일반적
제품을 변형할지, 특정 기능을 구현해야 할지 망설여질 때 창업 당시의 원래 의도를 생각해보면 자연스럽게 답이 나온다.


## chapter 2 객체지향 프로그래밍 패러다임

## 2.1 객체지향이란 무엇인가?

캡슐화, 추상화, 상속, 다형성

### 객체지향 설계 방법
- 책임과 기능을 나누고 어떤 클래스가 있는지 확인한다.
- 클래스를 정의하고, 클래스의 속성과 메서드를 정의한다.
- 클래스 간의 상호 작용을 정의한다.
- 클래스를 연결하고 실행 엔트리 포인트를 제공한다.

설계 : 코드를 어떻게 배치할 것인가?

### 2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가?
DDD 개발 방식을 적용하면 개발 프로세스가 완전히 바뀜
시스템이 복잡할수록 코드 재사용성과 유지 관리 용이성에 대한 요구 사항이 높아지기 때문에 초기 설계에 더 많은 시간과 에너지를 투자해야 한다.


Service 클래스의 책임
- 저장소 계층과의 통신
- 도메인 모델의 비즈니스 논리를 결합
- Service 클래스 기능과 무관한 타 시스템과의 상호 작용

### 2.7 추상 클래스와 인터페이스

is-a 관계를 나타내고자 하고 코드 재사용 문제를 해결하려면 추상 클래스
has-a 관계를 나타내고 코드 재사용 문제가 아닌 추상화 문제를 해결하려면 인터페이스를 사용

### 2.8 인터페이스 기반 프로그래밍 : 모든 클래스에 대해 인터페이스를 정의해야 할까?
구현이 아닌 인터페이스 기반 설계 사상의 원래 의도는 구현에서 인터페이스를 분리하고 불안정한 구현을 캡슐화하고 안정적인 인터페이스를 노출하는 것

### 2.9 상속보다 합성
AbstractBird -> AbstractFlyableBird, AbstractUnFlyableBird > AbstractFlyableTweetableBird ...

위의 상속 문제는 합성, 인터페이스, 위임을 통해 해결할 수 있음

Flyable, Tweetable 합성


## chapter 3 설계 원칙

SOLID : 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙 
KISS : Keep It Short and Simple (과도하게 최적화하지 않는다.)
YAGNI : you ain't gonna need it (과도하게 설계하지 마라)
DRY : don't repeat yourself (두 개의 동일한 중복 코드가 반드시 DRY 원칙에 위배되는 것은 아니다)
LoD : law of demeter (최소 지식의 원칙)


## chapter 4 코딩 규칙

명명과 주석, 코드 스타일, 코딩 팁

### 4.1 명명과 주석
전역 변수와 같이 범위가 큰 변수의 경우 긴 이름을 사용하는 것이 좋다.

- 문맥 정보를 사용한 명명 단순화
- 비즈니스 용어집을 사용한 명명 통일
- 명명은 정확하지만 추상적이어야 한다.
- 주석에 반드시 포함되어야 하는 것들 (무엇, 왜, 어떻게)
- 주석이 많다고 좋은 것은 아니다


### 4.2 코드 스타일

- 클래스, 함수의 적절한 크기
- 한 줄의 적절한 길이
- 빈 줄을 활용한 코드 블록 구분
- 통일된 들여쓰기
- 클래스의 멤버 순서

### 4.3 코딩팁
- 복잡한 코드의 모듈화
- 함수의 매개변수 관리 (보통 5개 이상이면 많음 많으면 캡슐화)
- 함수의 플래그 매개변수 제거
- 깊은 중첩 코드 제거

## chapter 5 리팩터링 기법

### 5.1 리팩터링의 네 가지 요소 : 목적, 대상, 시기, 방법

- 리팩터링의 목적
> 리팩터링은 코드에 대한 이해를 쉽게 하기 위해 소프트웨어의 내부 구조를 개선하는 것으로, 소프트웨어의 외부 동작을 변경하지 않고 수정 비용을 줄이는 것을 목적으로 한다.

- 리팩터링의 시기 (지속적인 리팩터링)

### 5.2 단위 테스트
단윈 테스트는 리팩터링이 잘못되지 않도록 하는 효과적인 수단이다.
- 버그를 찾아줌
- 설계에서 문제를 찾는데 도움이 됨
- 통합 테스트를 보완
- 리팩터링 과정에 해당
- 코드에 익숙해짐
- TDD 개선

### 5.4 디커플링
코드의 복잡성을 제어하는 가장 효과적인 방법은 디커플링이다.
디커플링을 통해 응집도가 높고 결합도가 낮은 코드를 만들 수 있으며, 이와 같은 방식으로 코드를 리팩터링하면 코드의 복잡성을 효과적으로 제어할 수 있다.

#### 5.4.3 코드 디커플링 방법

- 캡슐화와 추상화
- 중간 계층
- 모듈화와 계층화

- 단일 책임
- 구현이 아닌 인터페이스 기반 프로그래밍
- 의존성 주입
- 상속보다는 합성
- LoD

## chapter 6 생성 디자인 패턴

생성 디자인 패턴은 주로 객체 생성 문제를 해결하고 복잡한 생성 프로세스를 캡슐화하며 객체의 생성 코드와 사용 코드를 분리한다.

- 싱글턴 패턴 : 어떤 클래스의 객체 또는 인스턴스를 단 하나만 생성할 수 있다면, 해당 클래스는 싱글턴 클래스이며, 이 디자인 패턴을 싱글턴 패턴이라고 한다.
- 팩터리 패턴 : 단순 팩터리, 팩터리 메서드, 추상 팩터리
  - 팩터리 패턴을 사용하여 생성 과정을 캡슐화할 수 있다. 이때 생성 과정의 변경 사항은 호출자에게 투명성을 가진다.
  - 생성 과정을 팩터리 클래스로 추출한 경우, 재사용할 수 있다.
  - 복잡한 생성 과정을 캡슐화하므로, 호출자는 객체 생성 방법을 알 필요가 없다.
  - 생성 과정과 사용 과정을 분리하여 복잡한 코드를 간결하게 바꿀 수 있다.
- 빌더 패턴 : 생성자의 매개변수 목록이 매우 길어질 때, 제약 조건이 많을 때
- 프로토타입 패턴 : 객체의 생성 비용은 크지만, 동일한 클래스 기반으로 생성된 차이가 그리 크지 않은 객체 생성할 때


## chapter 7 구조 디자인 패턴

- 프록시 패턴 : 원본 클래스에 연관 없는 기능을 추가할 떄 (인터페이스 기반, 리플렉션 기반의 동적 프록시)
- 데코레이터 패턴 : 원본 클래스와 관련이 있거나 향상된 기능을 추가
- 어댑터 패턴 : 코드 호환성 문제를 해결하는 데 사용
- 브리지 패턴 : 합성의 폭발 문제를 해결하는데 사용
- 퍼사드 패턴
- 복합체 패턴 : 객체들을 트리 구조들로 구성한 후, 이러한 구조들과 개별 객체들처럼 작업할 수 있도록 하는 구조 패턴
- 플라이웨이트 패턴 : 객체를 재사용하여 메모리를 절약하는것, 공유되는 객체는 불변

## chapter 8 행동 디자인 패턴



