# Unit Testing

## Part1 더 큰 그림

### 1 단위 테스트의 목표


테스트에 드는 노력을 가능한 한 줄이고 그에 따르는 이득을 최대화해야 한다.

어떤 단위 테스트 기술이 좋은지를 구별

#### 1.1 단위 테스트 현황

단위 테스트를 작성해야 하는가? -> 좋은 단위 테스트를 작성하는 것은 어떤 의미인가? 로 바뀜
이상적인 단위 테스트에 대해 정확하고 과학적인 정의를 다룸

#### 1.2 단위 테스트의 목표

단위 테스트의 목표는 - 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것이다.

##### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

기반 코드를 리팩터링할 때 테스트도 리팩터링하라
각 코드 변경 시 테스트를 실행하라
테스트가 잘못된 경고를 발생시킬 경우 처리하라
기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라


#### 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

##### 1.3.1 코드 커버리지 지표에 대한 이해

커버리지 = 제품 코드 라인 수 / 전체 라인 수
분기 커버리지 = 통과 분기 / 전체 분기 수

##### 1.3.3 커버리지 지표에 관한 문제점
테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.


#### 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

개발 주기에 통합, 코드베이스에서 가장 중요한 부분만을 대상으로 함, 최소한의 유지비로 최대의 가치를 끌어냄


### 2 단위 테스트란 무엇인가

SUT (System Under Test)
MUT (Method Under Test)

#### 2.1 단위 테스트의 정의

작은 코드 조각을 검증
빠르게 수행하고,
격리된 방식으로 처리하는 자동화된 테스트다. (고전파와 런던파를 나눔)


##### 2.1.1 격리 문제에 대한 런던파의 접근
Mocking

##### 2.1.2 격리 문제에 대한 고전파의 접근
각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다.


#### 2.2 단위 테스트의 런던파와 고전파

차이 (런던, 고전)
격리 요구 사항
테스트 대상 코드 조각의 구성 요소
의존성 처리


##### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

고전파는 공유 의존성만 교체 대상
협력자 런더파에서는 공유 의존성, 변경 가능한 의존성이 교체 대상

#### 2.3 고전파와 런던파의 비교
고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.

런던파는
입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인
서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.
테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있따.


##### 2.3.1 한 번에 한 클래스만 테스트하기

좋은 입자성에 관한 요점은 단위 테스트에서 단위를 구성하는 것에 대한 논쟁과 관련이 있다.

테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다.


##### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
런던파는 의존성을 대채, 고전파는 테스트 대상 시스템을 설정하려면 전체 객체 그래프를 다시 생성해야 하는데, 작업이 많을 수 잇다.
사실 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.

##### 2.3.3 버그 위치 정확히 찾아내기
런던파는 버그 부분만 실패 고전파는 전체 시스템에 걸쳐 테스트 실패할 수 있음 하지만 이것은 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여준다.

##### 2.3.4 고전파와 런던파 사이의 다른 차이점

테스트 주도 개발을 통한 시스템 설계 방식
과도한 명세 문제

TDD
추가해야 할 기능과 어떻게 동작해야 하는지를 나타내는 실패 테스트를 작성한다.
테스트가 통과할 만큼 충분히 코드를 작성한다. 이 단계에서 코드가 깨끗하거나 명쾌할 필요는 없다.
코드를 리팩터링한다. 통과 테스트 보호하에서 코드를 안전하게 정리해 좀 더 읽기 쉽고 유지하기 쉽도록 만들 수 있다.

런던 스타일은 하향식 TDD
고전파는 도메인 모델을 시작으로 TDD

#### 2.4 두 분파의 통합 테스트

런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주

##### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트
통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트다.

### 3 단위 테스트 구조

단위 테스트 구조, 좋은 단위 테스트 명명법, 매개변수화된 테스트 작성, Fluent Assertions 사용


#### 3.1 단위 테스트를 구성하는 방법

준비, 실행, 검증 패턴을 사용해 단위 테스트를 구성하는 방법,
피해야 할 함정, 테스트를 가능한 한 읽기 쉽게 만드는 방법

##### 3.1.1 AAA 패턴
준비, 실행, 검증 패턴
Given When Then

기능을 개발하기 전에 실패할 테스트를 만들 때는 아직 기능이 어떻게 동작할지 충분히 알지 못한다. 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 이러한 기대에 부응하기 위한 시스템을 어떻게 개발할지 아는 것이 좋다.


##### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기
너무 많이 검증하면 나눠라

##### 3.1.3 테스트 내 if 문 피하기

##### 3.1.4 각 구절은 얼마나 커야 하는가?

준비 구절이 가장 큰 경우
실행 구절이 한 줄 이상인 경우를 경계하라 : 불변 위반 두 가지를 실행해야 하는 메서드인 경우 하나로 뽑아내는 것이 좋다. (캡슐화)

##### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가
SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의하는 것이 좋다.

##### 3.1.6 종료 단계는 어떤가
대부분의 단위 테스트는 종료 구절이 필요 없다.

##### 3.1.7 테스트 대상 시스템 구별하기
calculator 테스트 였다면 그냥 sut으로 표현할 수 있음

##### 3.1.8 준비, 실행, 검증 주석 제거하기
빈 줄로 구분하라


#### 3.2 xUnit 테스트 프레임워크 살표보기

#### 3.3 테스트 간 테스트 픽스처 재사용

테스트 픽스처를 재사용하는 첫 번째 방법은 테스트 생성자에서 픽스처를 초기화하는 것
(테스트 간 결합도가 높아짐, 테스트 가동성이 떨어짐)

##### 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다.
테스트 격리성을 떨어뜨림

##### 3.3.2 테스트 가동성을 떨어뜨리는 생성자 사용
준비 코드를 생성자로 추출할 때의 또 다른 단점은 테스트 가독성을 떨어뜨리는 것이다.

##### 3.3.3 더 나은 텍스트 픽스처 재사용법
두 번째 방법은 비공개 팩토리 메서드를 두는 것

#### 3.4 단위 테스트 명명법
테스트에 표현력이 있는 이름을 붙이는 것이 중요하다.

##### 3.4.1 단위 테스트 명명 지침
표현력 있고 읽기 쉬운 테스트 이름을 지으려면 다음 지침을 따르자

엄경한 명명 정책을 따르지 않는다. 표현의 자유를 허용
문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자. 도메인 전문가나 비즈니스 분석가가 좋은 예
단어를 밑줄 표시로 구분한다.

Should be 안티패턴 -> must or is

#### 3.5 매개변수화된 테스트 리팩터링하기
파라미터랑 결과만 같은 경우 파라미터라이즈 테스트


#### 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상