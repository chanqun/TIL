# Unit Testing

## Part1 더 큰 그림

### 1 단위 테스트의 목표


테스트에 드는 노력을 가능한 한 줄이고 그에 따르는 이득을 최대화해야 한다.

어떤 단위 테스트 기술이 좋은지를 구별

#### 1.1 단위 테스트 현황

단위 테스트를 작성해야 하는가? -> 좋은 단위 테스트를 작성하는 것은 어떤 의미인가? 로 바뀜
이상적인 단위 테스트에 대해 정확하고 과학적인 정의를 다룸

#### 1.2 단위 테스트의 목표

단위 테스트의 목표는 - 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것이다.

##### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

기반 코드를 리팩터링할 때 테스트도 리팩터링하라
각 코드 변경 시 테스트를 실행하라
테스트가 잘못된 경고를 발생시킬 경우 처리하라
기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라


#### 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

##### 1.3.1 코드 커버리지 지표에 대한 이해

커버리지 = 제품 코드 라인 수 / 전체 라인 수
분기 커버리지 = 통과 분기 / 전체 분기 수

##### 1.3.3 커버리지 지표에 관한 문제점
테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.


#### 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

개발 주기에 통합, 코드베이스에서 가장 중요한 부분만을 대상으로 함, 최소한의 유지비로 최대의 가치를 끌어냄


### 2 단위 테스트란 무엇인가

SUT (System Under Test)
MUT (Method Under Test)

#### 2.1 단위 테스트의 정의

작은 코드 조각을 검증
빠르게 수행하고,
격리된 방식으로 처리하는 자동화된 테스트다. (고전파와 런던파를 나눔)


##### 2.1.1 격리 문제에 대한 런던파의 접근
Mocking

##### 2.1.2 격리 문제에 대한 고전파의 접근
각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다.


#### 2.2 단위 테스트의 런던파와 고전파

차이 (런던, 고전)
격리 요구 사항
테스트 대상 코드 조각의 구성 요소
의존성 처리


##### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

고전파는 공유 의존성만 교체 대상
협력자 런더파에서는 공유 의존성, 변경 가능한 의존성이 교체 대상

#### 2.3 고전파와 런던파의 비교
고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.

런던파는
입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인
서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.
테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있따.


##### 2.3.1 한 번에 한 클래스만 테스트하기

좋은 입자성에 관한 요점은 단위 테스트에서 단위를 구성하는 것에 대한 논쟁과 관련이 있다.

테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다.


##### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
런던파는 의존성을 대채, 고전파는 테스트 대상 시스템을 설정하려면 전체 객체 그래프를 다시 생성해야 하는데, 작업이 많을 수 잇다.
사실 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.

##### 2.3.3 버그 위치 정확히 찾아내기
런던파는 버그 부분만 실패 고전파는 전체 시스템에 걸쳐 테스트 실패할 수 있음 하지만 이것은 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여준다.

##### 2.3.4 고전파와 런던파 사이의 다른 차이점

테스트 주도 개발을 통한 시스템 설계 방식
과도한 명세 문제

TDD
추가해야 할 기능과 어떻게 동작해야 하는지를 나타내는 실패 테스트를 작성한다.
테스트가 통과할 만큼 충분히 코드를 작성한다. 이 단계에서 코드가 깨끗하거나 명쾌할 필요는 없다.
코드를 리팩터링한다. 통과 테스트 보호하에서 코드를 안전하게 정리해 좀 더 읽기 쉽고 유지하기 쉽도록 만들 수 있다.

런던 스타일은 하향식 TDD
고전파는 도메인 모델을 시작으로 TDD

#### 2.4 두 분파의 통합 테스트

런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주

##### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트
통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트다.

### 3 단위 테스트 구조

단위 테스트 구조, 좋은 단위 테스트 명명법, 매개변수화된 테스트 작성, Fluent Assertions 사용


#### 3.1 단위 테스트를 구성하는 방법

준비, 실행, 검증 패턴을 사용해 단위 테스트를 구성하는 방법,
피해야 할 함정, 테스트를 가능한 한 읽기 쉽게 만드는 방법

##### 3.1.1 AAA 패턴
준비, 실행, 검증 패턴
Given When Then

기능을 개발하기 전에 실패할 테스트를 만들 때는 아직 기능이 어떻게 동작할지 충분히 알지 못한다. 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 이러한 기대에 부응하기 위한 시스템을 어떻게 개발할지 아는 것이 좋다.


##### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기
너무 많이 검증하면 나눠라

##### 3.1.3 테스트 내 if 문 피하기

##### 3.1.4 각 구절은 얼마나 커야 하는가?

준비 구절이 가장 큰 경우
실행 구절이 한 줄 이상인 경우를 경계하라 : 불변 위반 두 가지를 실행해야 하는 메서드인 경우 하나로 뽑아내는 것이 좋다. (캡슐화)

##### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가
SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의하는 것이 좋다.

##### 3.1.6 종료 단계는 어떤가
대부분의 단위 테스트는 종료 구절이 필요 없다.

##### 3.1.7 테스트 대상 시스템 구별하기
calculator 테스트 였다면 그냥 sut으로 표현할 수 있음

##### 3.1.8 준비, 실행, 검증 주석 제거하기
빈 줄로 구분하라


#### 3.2 xUnit 테스트 프레임워크 살표보기

#### 3.3 테스트 간 테스트 픽스처 재사용

테스트 픽스처를 재사용하는 첫 번째 방법은 테스트 생성자에서 픽스처를 초기화하는 것
(테스트 간 결합도가 높아짐, 테스트 가동성이 떨어짐)

##### 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다.
테스트 격리성을 떨어뜨림

##### 3.3.2 테스트 가동성을 떨어뜨리는 생성자 사용
준비 코드를 생성자로 추출할 때의 또 다른 단점은 테스트 가독성을 떨어뜨리는 것이다.

##### 3.3.3 더 나은 텍스트 픽스처 재사용법
두 번째 방법은 비공개 팩토리 메서드를 두는 것

#### 3.4 단위 테스트 명명법
테스트에 표현력이 있는 이름을 붙이는 것이 중요하다.

##### 3.4.1 단위 테스트 명명 지침
표현력 있고 읽기 쉬운 테스트 이름을 지으려면 다음 지침을 따르자

엄경한 명명 정책을 따르지 않는다. 표현의 자유를 허용
문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자. 도메인 전문가나 비즈니스 분석가가 좋은 예
단어를 밑줄 표시로 구분한다.

Should be 안티패턴 -> must or is

#### 3.5 매개변수화된 테스트 리팩터링하기
파라미터랑 결과만 같은 경우 파라미터라이즈 테스트


#### 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상

## Part 2 개발자에게 도움이 되는 테스트 만들기

### 4 좋은 단위 테스트의 4대 요소

#### 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기
회귀 방지
리팩터링 내성
빠른 피드백
유지 보수성

##### 4.1.1 첫 번째 요소 : 회귀 방지
코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우
테스트 중에 실행되는 코드의 양, 코드 복잡도, 코드의 도메인 유의성

코드의 양뿐만 아니라 복잡도와 도메인 유의성도 중요 -> 비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 떄문이다.

##### 4.1.2 두 번째 요소 : 리팩터링 내성
테스트를 빨간색으로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.

테스트 실패하지 않았는데 실패했다고 뜨는 것 -> 거짓양성 (신뢰를 떨어뜨림)

##### 4.1.3 무엇이 거짓 양성의 원인인가?
세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.

##### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기

#### 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계
테스트 정확도 극대화, 거짓 양성과 거짓 음성의 중요성

##### 4.2.1 테스트 정확도 극대화
버그 있음과, 버그 없음얼 얼마나 잘 나타내는지

##### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계

#### 4.3 세 번째 요소와 네 번째 요소 : 빠른 피드백과 유지 보수성
빠른 피드백
유지 보수성

테스트가 얼마나 이해하기 어려운가: 테스트는 코드 라인이 적을수록 더 읽기 쉽다. (테스트 코드를 일급 시민 으로 취급하라)
테스트가 얼마나 실행하기 어려운가: 테스트가 프로세스 외부 종속성으로 작동하면, 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 운영하는데 시간을 들여야 한다.

#### 4.4 이상적인 테스트를 찾아서
! 회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성


##### 4.4.1 이상적인 테스트를 만들 수 있는가?
처음 세 가지 특성은 상호 배타적임

##### 4.4.2 엔드 투 엔드 테스트
거짓 양성 확률은 낮지만 느리다

##### 4.4.3 간단한 테스트
매우 빠르고 빠른 피드백을 제공, 간단한 테스트는 회귀를 나타내지 않음

##### 4.4.4 깨지기 쉬운 테스트
회귀를 잡을 가능성은 크지만 거짓 양성을 나타내기 쉬움

##### 4.4.5 이상적인 테스트를 찾아서 : 결론
CAP 정리와 비슷 : 분산 데이터 저장소가 일관성, 가용성, 분할 내성을 동시에 제공할 수 없음과 유사
절충안을 찾아야한다.


#### 4.5 대중적인 테스트 자동화 개념 살펴보기

##### 4.5.1 테스트 피라미드 분해

단위테스트 > 통합테스트 > 엔드투엔드테스트

##### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

화이트박스 회귀방지 높고 리팩터링 내성 낮음
블랙박스 회귀방지 낮고 리팩터링 내성 높음

### 5 목과 테스트 취약성

목과 테스트 취약성 사이에는 깊고 불가피한 관련이 있음


#### 5.1 목과 스텁 구분
목은 테스트 대상 시스템과 그 협력자 사이의 상호 작용을 검사할 수 있음
스텁은 다름

##### 5.1.1 테스트 대역 유형

테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 다섯 가지가 있다

(목, 스파이), (스텁, 더미, 페이크)

목은 SUT와 관련 의존성 간의 상호 작용을 모방하고 검사하는 반면, 스텁은 모방만 한다.


##### 5.1.2 도구로서의 목과 테스트 대역으로서의 목

목 라이브러리리는 목클래스를 사용하지만 클래스의 인스턴스는 목이 아니라 스텁이다.


##### 5.1.3 스텁으로 상호 작용을 검증하지 말라

목은 SUT에서 관련 의존성으로 나가는 상호 작용을 모방하고 검사하는 반면,
스텁은 내부로 들어오는 상호 작용만 모방하고 검사하지 않는다.

##### 5.1.4 목과 스텁 함께 쓰기

호출을 검증, 스텁과의 상호 작용을 검증하지 말라는 규칙은 위배되지 않음


##### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
목과 스텁의 개념은 명령 조회 분리 CQS 원칙과 관련이 있다.


메서드가 사이드 이펙트를 일으키면 해당 메서드의 반환 타입이 void인지 확인하라.
그리고 메서드가 값을 반환하면 사이드 이펙트가 없어야 한다.

이메일 보내는 사이드 이펙트가 있으면 목이라 할 수 있고
조회하고 데이터베이스 상태를 변경하지 않으면 스텁이다.


#### 5.2 식별할 수 있는 동작과 구현 세부 사항
테스트는 어떻게가 아니라 무엇에 중점을 둬야 한다.

##### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다.

모든 제품 코드는 2차원으로 분류할 수 있다.
공개 API 또는 비공개 API
식별할 수 있는 동작 또는 구현 세부 사항

클라이언트가 목표를 달성하는데 도움이 되는 작업을 노출하라.
클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출하라.

##### 5.2.2 구현 세부 사항 유출: 연산의 예
단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.

##### 5.2.3 잘 설계된 API와 캡슐화
구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

#### 5.3 목과 테스트 취약성 간의 관계
##### 5.3.1 육각형 아키텍처 정의
도메인 계층은 애플리케이션의 중심부이기 때문에 도표의 중앙에 위치.
애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정

도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
애플리케이션 내부 통신
애플리케이션 간의 통신


##### 5.3.2 시스템 내부 통신과 시스템 간 통신
시스템 내부 통신은 구현 세부 사항이고, 시스템 간 통신은 그렇지 않다.

#### 5.4 단위 테스트의 고전파와 런던파 재고

##### 5.4.1 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다
공유 의존성
프로세스 외부 의존성
비공개 의존성

##### 5.4.2 목을 사용한 동작 검증
종종 목이 동작을 검증한다고 한다. 하지만 대부분의 경우 그렇지 않다.

### 6 단위 테스트 스타일
출력 기반, 상태 기반, 통신 기반

출력 기반 테스트 스타일은 아무데서나 사용할 수 없으며
순수 함수 방식으로 작성된 코드에만 적용된다.


#### 6.1 단위 테스트의 세 가지 스타일

##### 6.1.1 출력 기반 테스트 정의
전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.

##### 6.1.2 상태 기반 스타일 정의

상태 기반 스타일은 작업이 완료된 후 시스템 상태를 확인하는 것이다.

##### 6.1.3 통신 기반 스타일 정의

이 스타일은 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

스타일과 단위 테스트 분파
단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 런던파는 이와 반대로 선택한다. 두 분파는 출력 기반 테스트를 사용한다.


#### 6.2 단위 테스트 스타일 비교

##### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

회귀 방지 지표는 다음 세 가지 특성으로 결정
테스트 중에 실행되는 코드의 양, 코드 복잡도, 도메인 유의성

##### 6.2.2 리팩터링 내성 지표로 스타일 비교하기

리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성수에 대한 척도다. 결국 거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과다.

캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.


##### 6.2.3 유지 보수성 지표로 스타일 비교하기
테스트를 이해하기 얼마나 어려운가
테스트를 실행하기 얼마나 어려운가


출력 기반, 상태 기반, 통신 기반 순으로 유지 보수성이 좋다.

#### 6.3 함수형 아키텍처 이해

##### 6.3.1 함수형 프로그래밍이란?
수힉적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다.

사이드 이펙트가 없다.

##### 6.3.2 함수형 아키텍처란?
함수형 프로그래밍의 목표는 사이트 이펙트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는 것이다.


가변 셸은 모든 입력을 수정한다.
함수형 코어는 결정을 생성한다.
셸은 결정을 사이드 이펙트로 변환한다.


##### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교
함수형 아키텍처와 육각형 아키텍처는 비슷한 점이 많다.
공통점
결정과 실행을 분리
의존성 간의 단방향 흐름

차이점
사이드 이펙트에 대한 처리

#### 6.4 함수형 아키텍처와 출력 기반 테스트로의 전환
프로세스 외부 의존성에서 목으로 변경
목에서 함수형 아키텍처로 변경

##### 6.4.1 감사 시스템 소개
조직의 모든 방문자를 추적하는 감사 시스템

#### 6.5 함수형 아키텍처의 단점 이해하기

##### 6.5.1 함수형 아키텍처 적용 가능성
함수형 코어의 클래스는 협력자로 작동하면 안 되고, 작업의 결과인 값으로 작동해야 한다.


##### 6.5.2 성능 단점
함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성간의 절충이다.

##### 6.5.3 코드베이스 크기 증가
궁극적으로는 코드 복잡도가 낮아지짐나 초기에 코딩이 더 필요
순수성이 많은 비용이 든다면 순수성을 따르지 마라

### 7 가치 있는 단위 테스트를 위한 리팩터링

#### 7.1 리팩터링할 코드 식별하기
리팩터링의 방향을 설명하고자 코드를 네 가지 유형으로 분류하는 방법

##### 7.1.1 코드의 네 가지 유형
 복잡도 또는 도메인 유의성
코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는지

 협력자 수
협력자는 가변 의존성이거나 프로세스 외부 의존성이다.
프로세스 외부 의존성을 가진 모든 통신은 도메인 계층 외부의 클래스에 위임하는 것이 좋다

코드 복잡도, 도메인 유의성, 협력자 수의 조합으로 다음 네 가지 코드 유형을 볼 수 있다.
도메인 모델과 알고리즘, 간단한 코드, 컨트롤러, 지나치게 복잡한 코드

! 코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 한다.
! 좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 좋다.


##### 7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

지나치게 복잡한 코드를 쪼개려면 험블 객체 패턴을 써야 한다.

테스트 대상 코드의 로직을 테스트하려면, 테스트가 가능한 부분을 추출해야 한다. 결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 험블 래퍼가 된다.


험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙을 지키는 것이다. 이 패턴을 적용하면 비즈니스 로직을 거의 모든 것과 분리할 수 있다.
험블 객체 패턴은 오케스트레이션을 수행하는 코드에서 복잡한 코드를 분리하도록 특별히 설계됐다.
MVP, MVC, 도메인 주도 설계에 집계 패턴

#### 7.2 가치 있는 단위 테스트를 위한 리팩터링하기
##### 7.2.1 고객 관리 시스템 소개

##### 7.2.2 1단계: 암시적 의존성을 명시적으로 만들기
##### 7.2.3 2단계: 애플리케이션 서비스 계층 도입
##### 7.2.4 3단계: 애플리케이션 서비스 복잡도 낮추기
##### 7.2.5 4단계: 새 Company 클래스 소개


#### 7.3 최적의 단위 테스트 커버리지 분석
복잡도와 도메인 유의성이 높음, 낮음
협력자가 거의 없음, 많음

##### 7.3.1 도메인 계층과 유틸리티 코드 테스트하기
##### 7.3.2 나머지 세 사분면에 대한 코드 테스트하기
##### 7.3.3 전제 조건을 테스트해야 하는가?
도메인 유의성이 있는 모든 전제 조건을 테스트하라 직원 수가 0미만으로 내려가는 경우 같은

#### 7.4 컨트롤러에서 조건부 로직 처리
 저장소에서 데이터 검색, 비즈니스 로직 실행, 데이터를 다시 저장소에 저장

##### 7.5.1 CanExcute / Excute 패턴 사용
##### 7.5.2 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적

결론
추상화할 것을 테스트하기보다 추상화를 테스트하는 것이 더 쉽다.

## Part 3 통합 테스트
단위 테스트는 통과 했지만 애플리케이션이 작동하지 않을 수 있음

### 8 통합 테스트를 하는 이유

단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다.

#### 8.1 통합 테스트는 무엇인가?
통합 테스트는 테스트 스위트에서 중요한 역할을 하며, 단위 테스트 개수와 통합 테스트 개수의 균형을 맞추는 것도 중요하다.

##### 8.1.1 통합 테스트의 역할

단위 테스트 요구 사항을 만족하지 않은 모든 것
 단일 동작 단위를 검증하고, 빠르게 검증하고, 다른 테스트와 별도로 처리하는 것

##### 8.1.2 다시 보는 테스트 피라미드
단위 테스트와 통합 테스트 간의 균형을 유지하는 것이 중요하다.

통합 테스트가 프로세스 외부 의존성에 직접 작동하면 느려지며, 이러한 테스트는 유지비가 많이 든다.
 프로세스 외부 의존성 운영이 필요함
 관련된 협력자가 많아서 테스트가 비대해짐
대신 회귀 방지가 우수하며, 제품과의 결합도가 낮아서 리팩터링 내성도 우수하다.


##### 8.1.3 통합 테스트와 빠른 실패

버그를 빨리 나타나게 하는 것을 빠른 실패 원칙이라고 하며, 통합 테스트에서 할 수 있는 대안이다.

#### 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

통합 테스트는 시스템이 프로세스 외부 의존성과 어떻게 통합하는지를 검증한다.
이러한 검증을 구현하는 방식은 두 가지가 있다.
실제 프로세스 외부 의존성을 사용하거나 해당 의존성을 목으로 대체하는 것이다.


##### 8.2.1 프로세스 외부 의존성의 두 가지 유형
 관리 의존성 : 애플리케이션을 통해서만 접근할 수 있음 (DB)
 비관리 의존성 :상호 작용을 외부에서 볼 수 있음 SMTP, 메시지


관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라


##### 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기
공유 테이블 조심해야한다
공유 테이블은 외부에서 볼 수 있고 애플리케이션과 테이블 간의 통신 방식을 주의해야 하기 때문이다.

##### 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?
데이터베이스를 그대로 테스트할 수 없으면 통합 테스트를 아예 장성하지 말고 도메인 모델의 단위 테스트에만 집중하라

#### 8.3 통합 테스트 : 예제

#### 8.4 의존성 추상화를 위한 인터페이스 사용
단위 테스트 영역에서 가장 많이 오해하는 주제 중 하나는 인터페이스 사용이다.

##### 8.4.1 인터페이스와 느슨한 결합
 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고,
 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP 원칙을 지키기 때문이다.

YAGNI (You aren’t gonna need it)
 기회 비용, 프로젝트 코드는 적을수록 좋다.

##### 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

의존성의 메서드를 가상으로 만들면 인터페이스에 의존하지 않고 목 기반을 클래스로 사용해 해당 의존성을 목으로 처리할 수 있다.

##### 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용

#### 8.5 통합 테스트 모범 사례
 도메인 모델 경계 명시하기
 애플리케이션 내 계층 줄이기
 순환 의존성 제거하기


##### 8.5.4 테스트에서 다중 실행 구절 사용
 준비, 실행, 검증, 실행, 검증
둘 이상의 실행 구절로 테스트를 작성하는 것이 타당한 이유를 생각해보면, 프로세스 외부 의존성을 관리하기 어려운 경우 뿐이다. 따라서 단위 테스트는 프로세스 외부 의존성으로 작동하지 않기 때문에 절대로 실행 구절이 여러 개 있어서는 안 된다.

#### 8.6 로깅 기능을 테스트하는 방법
 로깅을 조금이라도 테스트해야 하는가? : 지원 로깅과 진단 로깅의 차이
 어떻게 테스트하는가? : 로거위에 래퍼 도입하기
 얼마나 많으면 충분한가 : 신호 대비 잡음 비율
 로거 인스턴스를 어떻게 전달할까? : 정적 메서드를 사용하는 것

### 9 목 처리에 대한 모범 사례

목은 비관리 의존성에만 적용해야 한다.

#### 9.1 목의 가치를 극대화하기

##### 9.1.1 시스템 끝에서 상호 작용 검증하기
목을 사용할 때 항상 시스템 끝에서 비관리 의존성과의 상호 작용을 검증

비관리 의존성에 대한 호출은 애플리케이션을 떠나기 전에 몇 단계를 거친다. 마지막 단계를 선택하라.
외부 시스템과의 하위 호환성을 보장하는 가장 좋은 방법이며, 하위 호환성은 목을 통해 달성할 수 있는 목표다.


##### 9.1.2 목을 스파이로 대체하기

스파이는 목과 같은 목적을 수행하는 테스트 대역이다.
스파이는 수동으로 작성하는 반면에 목은 목 프레임워크의 도움을 받아 생성한다.

##### 9.1.3 IDomainLogger는 어떤가?

#### 9.2 목 처리에 대한 모범 사례
비관리 의존성에만 목 적용하기
시스템 끝에 있는 의존성에 대해 상호 작용 검증하기

통합 테스트에서만 목을 사용하고 단위 테스트에서는 하지 않기
항상 목 호출 수 확인하기
보유 타입만 목으로 처리하기

##### 9.2.1 목은 통합 테스트만을 위한 것

##### 9.2.2 테스트당 목이 하나일 필요는 없음

##### 9.2.3 호출 횟수 검증하기

##### 9.2.4 보유 타입만 목으로 처리하기

어댑터는 코드와 외부 환경 사이의 손상 방지 계층으로 작동한다
기본 라이브러리의 복잡성을 추상화하고
라이브러리에서 필요한 기능만 노출하며
프로젝트 도메인 언어를 사용해 수행할 수 있다.


### 10 데이터베이스 테스트

#### 10.1 데이터베이스 테스트를 위한 전제 조건
- 형상 관리 시스템에 데이터베이스 유지
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
- 데이터베이스 배포에 마이그레이션 기반 방식 적용

테스트를 용이하게 하면 보통 데이터베이스 상태도 개선된다.

##### 10.1.1 데이터베이스를 형상 관리 시스템에 유지

##### 10.1.2 참조 데이터도 데이터베이스 스키마다

##### 10.1.3 모든 개발자를 위한 별도의 데이터베이스 인스턴스
- 서로 다른 개발자가 실행한 테스트는 서로 간섭되기 때문
- 하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있기 때문

##### 10.1.4 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포
상태 기반 방식보다 마이그레이션 기반 방식을 선호하라

#### 10.2 데이터베이스 트랜잭션 관리

##### 10.2.1 제품 코드에서 데이터베이스 트랜잭션 관리하기
데이터베이스 트랜잭션에서 데이터베이스 연결 분리하기
- 업데이트할 데이터
- 업데이트 유지 또는 롤백 여부

작업 단위에는 비즈니스 연산의 영향을 받는 객체 목록이 있따.

##### 10.2.2 통합 테스트에서 데이터베이스 트랜잭션 관리하기
#### 10.3 테스트 데이터 생명 주기
- 통합 테스트를 순차적으로 실행하라
- 테스트 실행 간에 남은 데이터를 제거하라

##### 10.3.1 병렬 테스트 실행과 순차적 테스트 실행
- 도커 이미지를 유지 보수해야 하고
- 각 테스트마다 컨테이너 인스턴스가 있는지 확인
- 통합 테스트를 일괄 처리하고
- 다 사용한 컨테이너는 폐기해야 한다.

##### 10.3.2 테스트 실행 간 데이터 정리
- 각 테스트 전에 데이터베이스 백업 복원하기
- 테스트 종료 시점에 데이터 정리하기
- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
- 테스트 시작 시점에 데이터 정리하기

##### 10.3.3 인메모리 데이터베이스 피하기
- 테스트 데이터를 제거할 필요가 없음
- 작업 속도 향상
- 테스트가 실행될 때마다 인스턴스화 가능

##### 10.4 테스트 구절에서 코드 재사용하기
##### 10.4.1 준비 구절에서 코드 재사용하기
##### 10.4.2 실행 구절에서 코드 재사용하기
##### 10.4.3 검증 구절에서 코드 재사용하기

##### 10.4.4 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?

#### 10.5 데이터베이스 테스트에 대한 일반적인 질문
##### 10.5.1 읽기 테스트를 해야 하는가?
##### 10.5.2 리포지터리 테스트를 해야 하는가?


### 11 단위 테스트 안티 패턴

- 단위 테스트를 가능하게 하고자 비공개 메서드를 노출하게 되면 테스트가 구현에 결합되고, 결국 리팩터링 내성이 떨어짐, 비공개 메서드를 테스트하는 대산, 식별할 수 있는 동작으로 간접 테스트하라
- 비공개 메서드가 너무 복잡해서 공개 API로 테스트할 수 없다면 추상화가 누락됐다는 뜻, 비공개 메서드를 공개로 하지말고 해당 추상화를 별도 클래스로 추출하라,
- 비공개였던 상태를 단위 테스트만을 위해 노출하지 마라. 테스트는 제품 코드와 같은 방식으로 테스트 대상 시스템과 상호 작용해야 한다.
- 테스트를 작성할 때 특정 구현을 암시하지 말라. 블랙박스 관점에서 제품 코드를 검증하라. 도메인 지식을 테스트에 유출하지 않도록
- 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것
- 기능을 지키려고 구체 클래스를 목으로 처리해야 하면, 이는 단일 책임 원칙을 우반하는 결과
- 현재 시간을 앰비언트 컨텍스트로 하면 제품 코드가 오염되고 테스트하기가 더 어려워진다. (서비스나 일반 값의 명시적인 의존성으로 시간을 주입하라.)


