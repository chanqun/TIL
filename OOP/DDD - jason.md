## DDD와 소프트웨어 복잡성 (6월 27일)

#### 1. 들어가기전
- 우테코 교육개발팀 박재성 JASON

1년차떄부터 강의를 했음

> 10년이 지나도 사용할 수 있는 코드

- DDD 기술 규칙과 패턴이 DDD 구현에 방해가 될 수 있음

#### 2. 나는 왜 DDD를 하고 있는가?

- 1000줄 넘는 컨트롤러 분기문이 계속 추가 됨
- 자바스크립트, SQL에 비즈니스 규칙이 퍼져있었음 (코드가 아닌 운영 정책으로 존재하기도)

! 비즈니스 규칙을 한곳에 모아야한다 -> 클린 아키텍처를 찾음
엔티티는 가장 일반적이며 고수준인 규칙을 캡슐화한다.


다양한 방법으로 가치를 전달할 수 있음
(소프트웨어, 미술, 춤, 음악)

No Silver Bullet - Essence and Accident in Software Engineering
본질적 복잡성, 우발적 복잡성 (경력직 뽑을 때 많이 물어봄!!)

엘리베이터 문제 예시
누구에 문제인지 알아야한다. (거북이 스프 문제가 생각나긴함)

> 도메인
> "소프트웨어는 사람의 욕망과 욕구를 해결하려고 만든 창조물이다. 사람들의 욕망과 욕구가 개발자에게 전달됐을 때 우리는 그것을 도메인이라고 부릅니다." - 조영호
> 소프트웨어로 해결하고자 하는 문제 영역

> 도메인 모델
> 현실 세계에 존재하는 것을 가공하고 편집함
> 목적을 가진 의사소통 수단


- 문제가 너무 큼
- Divide and Conquer
- 관심사를 분리하고 격리하여 문제 해결에 집중할 범위를 정한다.
  - 관심사를 나눌 수 있는 방법 중 하나는 FAQ가 도움이 된다.


Sales Context : Support Context
-> Customer, Product가 동일하게 사용한다면
영역에 따라서 Customer가 나눠질 수 있음

좋은 BOUNDED CONTEXT

- 하나의 BOUNDED CONTEXT는 하나의 팀에만 할당되어야 한다.
  - 하나의 팀은 여러 개의 BOUNDED CONTEXT를 다룰 수 있다.
- 각각의 BOUNDED CONTEXT는 각각의 개발 환경을 가질 수 있다.
(영한님 MSA, 우아한 모놀리스)

Upstream, Downstream


#### 유비쿼터스 언어
- 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 함

#### 효과적인 모델링
- 표현해야 할 것을 더 쉽게 말하는 방법을 찾아낸 다음 그러한 새로운 아이디어를 다이어그램과 코드에 적용한다.

(fulfillment 할때도 그림부터 그리고 시작했었음 어떤 문제를 해결하는지 파악)


> 용어 사전 최신화는 주, 월 단위 당번이 있고 주기적으로 확인함

https://github.com/next-step/ddd-tactical-design

#### 도메인 주도 설계 기본 요소

#### VALUE OBJECT
- 불변 객체
- 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용

- 스레드 안정성이 있음

#### ENTITY
- 식별자를 가짐

#### AGGREGATE
- 관련 객체를 하나로 묶은 군집
- 유사하거나 동일한 라이프사이클을 가짐 > 비즈니스 규칙을 보장하는 단위, 불변식을 보장하는 단위


새로운 AGGREGATE
> 시스템이 기대하는 책임을 수행하며 일관성을 유지하는 단위
> 일관성은 항상 참이어야 하는 속성을 유지함으로써 달성
> 명령을 수행하기 위해 함께 조회하고 업데이트해야 하는 최소 단위

강의 신청 예제


비즈니스 규칙을 정리 > 도메인 모델을 만들기 > 시뮬레이션 해본다

30명 정원에서 60명이 신청하는 경우가 생겼음

- 다중 사용자 환경에서 동시성 제어 실패
- 설계 모델과 구현 모델 간의 불일치
- 도메인 전문가와 개발자와의 멘탈 모델 불일치


1. 외부에서 참조하는 녀석이 Root Entity가 된다.
강의 ID : 전역 식별자
회원 ID : 지역 식별자 애그리거트 루트 안에서만 의미가 생긴다. 

2. !!! 트랜잭션 오류가 발생한다.
강의 정보 수정, 수강생 정보 수정하면서 버전이 달라지게 됨
!!! 가장 중요한 것은 수강 신청이다.
나머지는 다름

3. 수강생을 별도에 aggregate로 분리

기존의 불변식은 어떻게 보장할 것인가?

4. 강의 수강생 VO를 만듬 (회원 ID, 승인 여부)
-> 강의 수강생이 업데이트 되면 수강생도 발생함


큰 애그리거트
- 다중 사용자 환경에서 실행되면 정기적으로 트랜잭션 오류가 발생
- 성능 및 확장성이 떨어짐
작은 애그리거트
- 통제 불능에 빠질 수 있음


> 데이터베이스의 동시성 제어보다 애플리케이션의 동시성 제어가 더 한눈에 들어온다.
> 도메인 전문가와 함께 모델을 검증하는 것이 코드를 작성하고 테스트하는 것보다 빠를 수 있다.


애그리거트 참조
> 두 개의 트랜잭션이 내포되지 않는다.
> ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다 


#### 리포지터리
spring repository annotation은 eric evans 책으로부터 비롯되었다.

#### 도메인 서비스
github.com/woowacourse-projects/nextstep
RefundPolicy

때로는 객체지향보다 절체지향이 나을 수 있다.

- 별도의 상태를 가지지 않고 행위만 가지는 결제 도메인 서비스가 필요하다.
- 도메인 로직을 밖으로 나가게하는 것을 막아주는 방파제 역할을 한다.
- 정첵을 다루는 것이 응용 계층으로 넘어가지 않도록 도메인 서비스를 만들게 된다.


#### 팩토리
- 어떤 객체를 생성하는 일이 복잡하다면 FACTORY를 이용해 이것을 캡슐화할 수 있다.
- Payment를 통해 Refund를 생성


### DDD가 성공할 수 있는 전제 조건
- 개발자만을 위한 것이 아님
- 이해관계자의 스폰서십이 적극적으로 필요함


Bounded Context를 쪼개거나 합치거나 해야할 일들이 많이 일어난다.
배민도 한 달 주기로 조직 개편이 이루어짐



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
## Q&A
* 끝에 가서 나는 이렇게 생각했는데? 이런것을 어떤 방식으로...?
  * 글로 모델링 한것에 대해서 기록
  * 용어 사전을 지속적으로 관리

* 이벤트와 서비스호출 어떤 방식을 선택하는가?
  * 일관성 지키는 규칙만 잘 정리하는 것이 중요

* 작은 스타트업도 DDD 를 쓰는 것이 좋은가?
  * 도메인 전문가 없이 개발
  * 그럴바에는 일단, 빠르게 개발하고 나중에 리팩터링하는 것이 좋지 않겠는가?
  * 전술적 전략에 대해서는 권장
  * 유비쿼터스 랭귀지만 잘 지켜준다면 초석은 마련

* 도메인지식 전파하는 방법
  * 새로운 사람이 왔을때 온보딩 용도로 이벤트스토밍 하면서 갱신하는 것이 어떤가?

* 도메인을 포조로 해야한다.
  * DB 변경을 해본 경험은 있어도
  * JPA -> Mybatis x
  * 더 큰 동기부여가 되지 않으면 더 큰 설계를 하지 않는다.

* DDD를 객체지향언어로만 해야한다?
  * 그것은 아니라고 생각
  * 결국, 중요한건 유비쿼터스 랭귀지

* 모델드리븐 디자인 측면에서 텍스트로 정리한 도메인지식이 잘 매핑되지 않는데 그 것은 어떻게?
  * 가상 시나리오 상에서 지속적으로 검증하는 방식으로...
  * 100% 설계하고 구현하는 것은 아니기 때문에 지속적으로 수정이 되어야한다는 것을 모두 공감해야한다고 생각

* 팀 단위로 바운디드 컨텍스트? 아니다 도메인 다루다가 용어가 흐트러지면 바운디드 컨텍스트?
  * 처음에는 1팀으로 가다가 쪼개는 방식이 더 좋다고 생각?

* 혼자만 하는 개발하는 사람에 대해서는...?
  * 리눅스 만든 토발즈 급이면 그래도 된다...
  * 커뮤니케이션에 보다 참여할 수 있도록 이끌어야 한다는 생각...