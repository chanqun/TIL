# 스프링으로 시작하는 리액티브 프로그래밍 (Spring WebFlux를 이용한 Non-Blocking 애플리케이션 구현)


## PART 01 리액티브 프로그래밍

### CHAPTER 01 리액티브 시스템과 리액티브 프로그래밍

#### 1.1 리액티브 시스템이란
반응을 잘하는 시스템, 클라이언트의 요청에 즉각적으로 응답함으로써 지연 시간을 최소화

#### 1.2 리액티브 선언문으로 리액티브 시스템 이해하기

- MEANS : 메시지 기반의 통신, 느슨한 결합, 격리성, 위치 투명성
- FORM : 탄력성과 회복성
- VALUE : 비동기 메시지 기반 통신을 바탕으로 한 회복성과 예측 가능한 규모 확장 알고리즘을 통해 시스템의 처리량을 자동으로 확장하고 축소하는 탄력성을 확보

#### 1.3 리액티브 프로그래밍이란?
Non-Blocking I/O 방식의 통신

#### 1.4 리액티브 프로그래밍의 특징
In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change

선언형, 데이터가 지속적으로 발생

#### 1.5 코드로 보는 명령형 프로그래밍 vs 선언형 프로그래밍
- 선언형 프로그래밍 방식에서는 동작을 구체적으로 명시하지 않고 목표만 선언한다.
- 코드가 간결하고 가독성이 좋아짐?
- 선언형 프로그래밍 방식은 함수형 프로그래밍으로 구성

#### 1.6 리액티브 프로그래밍 코드 구성
Publisher, Subscriber, Data Source, Operator

### CHAPTER 02 리액티브 스트림즈

#### 2.1 리액티브 스트림즈란?
데이터 스트림을 Non-Blocking이면서 비동기적인 방식으로 처리하기 위한 리액티브 라이브러리의 표준 사양
(RxJava, Reactor, Akka Streams, Java 9 Flow Api 등)

#### 2.2 리액티브 스트림즈 구성요소
- Publisher
- Subscriber
- Subscription (Publisher에 요청할 데이터의 개수를 지정하고, 데이터의 구독을 취소하는 역할)
- Processor (Publisher와 Subscriber 기능)


```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);

    public void onNext(T t);

    public void onError(Throwable t);

    public void onComplete();
}
```

```java
public interface Subscription {
    public void request(long n); // 데이터 n개 요청함
    public void cancel();
}
```

```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

#### 2.4 리액티브 스트림즈 관련 용어 정의
- Signal: Publisher와 Subscriber 간에 주고받는 상호작용
- Demand: Subscriber가 Publisher에게 데이터 요청
- Emit: 데이터 통지 내보내다
- Upstream/DownStream
- Sequence: Publisher가 emit하는 데이터의 연속적인 흐름을 정의해 놓은 것
- Operator: 연산자 정도 (just, filter, map)
- Source: 최초의 Original

#### 2.5 리액티브 스트림즈의 구현 규칙

Publisher 구현 규칙 요약
- 데이터 전송량 제한: Publisher는 Subscriber가 요청한 데이터 개수보다 더 많거나 같은 수의 onNext 시그널을 보낼 수 없습니다. 요청된 수보다 적은 데이터를 보내고 onComplete 또는 onError로 구독을 종료할 수 있습니다.
- 종료 시그널: 데이터 처리 실패 시 onError 시그널을, 성공적으로 종료되면 onComplete 시그널을 보내야 합니다.
- 구독 취소 간주: onError 또는 onComplete 시그널을 보내면 해당 Subscriber의 구독은 취소된 것으로 간주됩니다.
- 종료 후 시그널 금지: 일단 종료 상태(onError, onComplete) 시그널을 받으면 더 이상 시그널이 발생되지 않아야 합니다.
- 취소 요청 준수: 구독이 취소되면 Subscriber는 결국 시그널을 받는 것을 중지해야 합니다.
- 무한 스트림 예외: 무한 스트림의 경우 처리 중 에러가 발생하기 전까지는 종료 자체가 없으므로, 요청된 것보다 적은 수의 onNext를 보내고 종료하는 규칙에 대한 예외가 될 수 있습니다.

Subscriber 구현 규칙 요약
- 데이터 요청 책임: Subscriber는 Subscription.request(n)을 통해 Publisher에게 Demand 시그널을 보내어 데이터를 요청해야 합니다. 한 번에 처리할 수 있는 적절한 상한선만큼의 데이터 요청을 권장합니다.
- 종료 시그널 처리 중 메서드 호출 금지: onComplete() 및 onError(Throwable t) 메서드 내에서는 Subscription 또는 Publisher의 메서드를 호출해서는 안 됩니다. 이는 순환 및 경쟁 조건 방지를 위함입니다.
- 종료 시그널 수신 후 구독 취소 간주: onComplete 또는 onError 시그널을 수신하면 구독이 취소된 것으로 간주해야 합니다.
- 명시적 구독 취소: 구독이 더 이상 필요하지 않은 경우 Subscriber는 Subscription.cancel()을 호출하여 리소스를 해제해야 합니다.
- onSubscribe 호출 제한: Subscriber.onSubscribe()는 지정된 Subscriber에 대해 최대 한 번만 호출되어야 합니다.

Subscription 구현 규칙 요약
- request 동기 호출 허용: Subscriber가 onNext 또는 onSubscribe 내에서 동기적으로 Subscription.request를 호출하도록 허용해야 합니다.
- 취소 후 호출 효력 없음: 구독이 취소된 후 Subscription.request(long n) 또는 Subscription.cancel()을 추가적으로 호출해도 효력이 없어야 합니다.
- 잘못된 요청 처리: 구독이 취소되지 않은 동안 Subscription.request(long n)의 매개변수가 0보다 작거나 같으면 java.lang.IllegalArgumentException과 함께 onError 시그널을 보내야 합니다.
- cancel()의 의미: Subscription.cancel()은 구독을 취소하고 Publisher에게 시그널 전송을 중지하고 해당 구독자에 대한 참조를 삭제하도록 요청해야 합니다. 이를 통해 가비지 컬렉션이 가능해집니다.
- 메서드 호출 시 예외 처리: Subscription.cancel() 및 Subscription.request() 호출에 대한 응답으로 예외를 던지는 것을 허용하지 않습니다. 예외가 발생하면 해당 예외를 onError 시그널과 함께 보내야 합니다. (Reactive Streams에서는 메서드 호출 시 유효한 값 외에는 예외를 던지지 않는다는 의미로 "Return normally"라는 용어를 사용합니다.)
- 무제한 요청 지원: 구독은 무제한 수의 request 호출을 지원해야 하며, 최대 2^63−1 개의 Demand를 지원해야 합니다. 이는 무한 스트림 처리를 가능하게 합니다.

#### 2.6 리액티브 스트림즈 구현체
- RxJava
- Project Reactor
- Akka Streams
- Java Flow API


### CHAPTER 03 Blocking I/O와 Non-Blocking I/O

#### 3.1 Blocking I/O
Blocking I/O 문제점을 보완하기 위해 멀티스레딩 기법으로 추가 스레드 할당함
문제점이 있음
- 컨텍스트 스위칭
- 과다한 메모리 사용으로 오버헤드가 발생
- 스레드 풀에서 응답 지연이 발생할 수 있음

#### 3.2 Non-Blocking I/O
단점
- cpu를 많이 사용하는 작업이 포함된 경우에는 성능에 악영향을 줌
- blocking 요소가 포함된 경우 이점 발휘하기 힘듬

#### 3.3 Spring Framework에서의 Blocking I/O와 Non-Blocking I/O
스마트폰 태블릿, IOT 기술 발전으로 Blocking으로 감당하기 힘들어짐
Spring WebFlux

#### 3.4 Non-blocking I/O 방식의 통신이 적합한 시스템
- 학습 난이도 (DI, AOP, 서비스 추상화 등)
- 리액티브 프로그래밍 경험이 있는 개발 인력을 확보하는 것이 쉬운가

##### 3.4.1 대량의 요청 트래픽이 발생하는 시스템
##### 3.4.2 마이크로 서비스 기반 시스템
##### 3.4.3 스트리밍 또는 실시간 시스템

### CHAPTER 04 리액티브 프로그래밍을 위한 사전 지식

#### 4.1 함수형 인터페이스
#### 4.2 람다 표현식
(String a, String b) -> a.equals(b)

함수형 인터페이스의 추상 메서드를 람다 표현식으로 작성해서 메서드의 파라미터로 전달한다는 의미는 메서드 자체를 파라미터로 전달하는 것이 아니라 
함수형 인터페이스를 구현한 클래스의 인스턴스를 다 표현식으로 작성해서 전달한다는 것

#### 4.3 메서드 레퍼런스
(Car car) -> car.getCarName() = Car::getCarName
- ClassName :: static method 유형
- ClassName :: instance method 유형
- object : : instance method 유형
- ClassName :: new 유형

#### 4.4 함수 디스크립터

함수형 인터페이스 (Functional Interface)	함수 디스크립터 (Function Descriptor)
Predicate<T>	        T -> boolean
Consumer<T>	            T -> void
Function<T, R>	        T -> R
Supplier<T>	            () -> T
BiPredicate<L, R>	    (L, R) -> boolean
BiConsumer<T, U>	    (T, U) -> void
BiFunction<T, U, R>	    (T, U) -> R


## PART 02 Project Reactor

### CHAPTER 05 Reactor 개요
• Reactor는 Spring Framework 팀의 주도로 개발된 리액티브 스트림즈(Reactive Streams) 구현체입니다.
• Spring WebFlux 기반의 리액티브 애플리케이션을 만들 때 핵심적인 역할을 합니다.
• Reactor의 주요 특징은 다음과 같습니다:
◦ 리액티브 스트림즈 사양을 구현합니다.
◦ 논블로킹(Non-Blocking) 방식으로 JVM 위에서 실행되는 애플리케이션을 구현하는 데 핵심적입니다.
◦ Java의 함수형 API를 활용합니다.
◦ Flux는 N개 또는 무한대의 데이터를, Mono는 0개 또는 1개의 데이터를 emit(방출) 하는 Publisher 타입입니다.
◦ 마이크로서비스에 적합하며, 대량의 요청 처리와 지속적인 I/O 처리 기술에 적합합니다.
◦ 백프레셔(Backpressure)를 지원하여 Publisher로부터 전달되는 대량의 데이터가 Subscriber에게 과부하를 주지 않도록 제어합니다.
• "Hello, Reactor" 예시를 통해 데이터 생성(Publisher), 데이터 가공(Operator), 데이터 처리(Subscriber)의 핵심 요소를 살펴볼 수 있습니다.

### CHAPTER 06 마블 다이어그램(Marble Diagram)
• 마블 다이어그램은 리액티브 프로그래밍에서 비동기적인 데이터 흐름을 시각적으로 표현하는 도구입니다.
• 특히 Reactor에서 지원하는 Operator들의 동작 방식을 이해하는 데 중요합니다.
• 다이어그램의 구성 요소는 다음과 같습니다:
◦ 수평선: 데이터가 emit되는 시간 흐름을 나타내는 타임라인입니다.
◦ 원(Circle): 데이터가 emit되는 시점을 나타냅니다.
◦ 화살표: Operator의 입력과 출력을 나타냅니다.
◦ 수직선: 데이터 emit이 정상적으로 완료되었음을 의미합니다 (onComplete Signal).
◦ 'X' 표시: 에러가 발생하여 데이터 처리가 종료되었음을 의미합니다 (onError Signal).
• Mono는 단 하나의 데이터를 emit하는 Publisher 타입이며, Flux는 0개 또는 1개 이상의 데이터를 emit할 수 있는 Publisher 타입입니다.

### CHAPTER 07 Cold Sequence와 Hot Sequence
• Cold Sequence는 Subscriber가 구독할 때마다 데이터 흐름이 처음부터 다시 시작되는 특성을 가집니다. 마치 카세트 플레이어처럼, 새로운 구독자가 생길 때마다 노래가 처음부터 재생되는 것과 같습니다.
• Hot Sequence는 Subscriber의 구독 시점과 상관없이 데이터가 처음부터 다시 전달되지 않고, 구독 시점 이후에 emit된 데이터만 전달받을 수 있습니다. 콘서트에 늦게 입장한 관객이 이미 공연된 노래는 들을 수 없는 것과 유사합니다.
• Cold Sequence를 Hot Sequence로 변환하는 Operator로는 share() 와 cache() 등이 있습니다.

### CHAPTER 08 Backpressure
• Backpressure는 Publisher가 끊임없이 emit하는 대량의 데이터를 Subscriber가 안정적으로 처리하고 과부하가 걸리지 않도록 데이터 처리를 제어하는 방식입니다.
• Reactor에서 Backpressure를 처리하는 방식 중 하나는 Subscriber가 Publisher에게 데이터 개수(Demand)를 요청하는 것입니다 (Subscription.request()).
• Reactor가 제공하는 다양한 Backpressure 전략은 다음과 같습니다:
◦ IGNORE 전략: Backpressure를 적용하지 않습니다. Subscriber가 처리 속도를 따라가지 못해도 Publisher는 계속 데이터를 emit하며, 이로 인해 IllegalStateException이 발생할 수 있습니다.
◦ ERROR 전략: Downstream(Subscriber)의 데이터 처리 속도가 Upstream(Publisher)의 emit 속도를 따라가지 못하면 Exception을 발생시켜 데이터를 폐기합니다.
◦ DROP 전략: Downstream으로 전달할 버퍼가 가득 찰 경우, 버퍼 밖에서 대기 중인 데이터 중 먼저 emit된 데이터부터 Drop (폐기)하여 버퍼를 비우는 전략입니다.
◦ LATEST 전략: 버퍼가 가득 찰 경우, 버퍼 밖에서 대기 중인 데이터 중 가장 최근(나중에) emit된 데이터로 버퍼를 채우는 전략입니다. 오래된 데이터는 폐기됩니다.
◦ BUFFER 전략: 버퍼가 가득 찰 때 버퍼 내부의 데이터를 폐기하지 않고 버퍼링을 지원합니다. 버퍼가 가득 찼을 때 버퍼 외부의 데이터를 폐기하는 DROP_LATEST와 버퍼 내부에서 가장 오래된 데이터를 폐기하는 DROP_OLDEST가 있습니다.

### CHAPTER 09 Sinks
• Sinks는 Reactive Streams의 Signal을 프로그래밍 방식으로 push(전송)할 수 있는 구조를 의미합니다.
• Signal 이벤트(onNext, onComplete, onError)를 프로그래밍 방식으로 발생시킬 수 있습니다.
• 기존의 generate() 또는 create() Operator와 달리, Sinks는 멀티스레드 환경에서 스레드 안전성(Thread Safety)을 보장하여 예상치 못한 동작을 방지합니다.
• Reactor에서 제공하는 Sinks의 주요 종류는 다음과 같습니다:
◦ Sinks.One: 단 한 건의 데이터를 프로그래밍 방식으로 emit할 때 사용됩니다.
◦ Sinks.Many: 여러 건의 데이터를 여러 가지 방식으로 전송하는 기능을 제공합니다 (예: unicast, multicast).

### Chapter 10: Scheduler (스케줄러)
◦ Reactor에서 스레드 관리 역할을 하는 Scheduler에 대해 이해하게 됩니다.
◦ Scheduler를 이해하기 위해 스레드의 개념을 먼저 살펴보고, Reactor에서 지원하는 Scheduler의 종류와 그 사용법을 알아봅니다.
◦ 주요 내용은 스레드의 개념 이해, Scheduler의 역할, Scheduler를 위한 전용 Operator (publishOn()과 subscribeOn()의 동작 이해), Scheduler의 종류를 다룹니다.

### Chapter 11: Context (컨텍스트)
◦ Reactor Sequence 상태를 저장하고 저장된 상태 값을 활용할 수 있게 해 주는 Context에 대해 학습합니다.
◦ Context의 개념 및 동작 방식과 Reactor에서 자주 사용되는 Context API를 설명합니다.

### Chapter 12: Debugging (디버깅)
◦ Reactor Sequence를 디버깅하는 다양한 방법을 살펴보고, 각각의 장단점을 알아봅니다.
◦ Debug Mode, checkpoint() Operator, log() Operator를 사용한 디버깅 방법을 포함합니다.

### Chapter 13: Testing (테스트)
◦ Reactor Sequence를 테스트하는 방법을 소개합니다.
◦ StepVerifier, TestPublisher, PublisherProbe 등을 사용한 테스트 방법을 학습합니다

### CHAPTER 14 Operators
• Operator는 Reactor에서 제공하는 가장 중요한 구성 요소 중 하나로, 데이터 흐름에 다양한 가공(Filtering, Transformation 등)을 적용하는 역할을 합니다.
• 다양한 Operator를 통해 데이터의 생성, 필터링, 변환, 시간 제어, 에러 처리, 멀티캐스팅 등을 수행할 수 있습니다.
• 주요 Operator 범주는 다음과 같습니다:
◦ Sequence 생성 Operator: justOrEmpty, fromIterable, fromStream, range, defer, using, generate, create.
◦ Sequence 필터링 Operator: filter, filterWhen, skip, take, next.
◦ Sequence 변환 Operator: map, flatMap, concat, merge, zip, and, collectList, collectMap, groupBy.
◦ Sequence의 내부 동작 확인을 위한 Operator (Side-effect): doOnSubscribe, doOnRequest, doOnNext, doOnComplete, doOnError, doOnCancel, doOnTerminate, doOnEach, doOnDiscard, doAfterTerminate, doFirst, doFinally.
◦ 에러 처리 Operator: error, onErrorReturn, onErrorResume, onErrorContinue, retry.
◦ Sequence 동작 시간 측정 Operator: elapsed.
◦ Flux Sequence 분할 및 버퍼링 Operator: window, buffer, bufferTimeout, groupBy.
◦ 다수의 Subscriber에게 Flux를 멀티캐스팅(Multicasting)하기 위한 Operator: publish, autoConnect, refCount


## PART 03 Spring WebFlux

### CHAPTER 15 Spring WebFlux 개요

#### 15.1 Spring WebFlux의 탄생 배경
대량의 요청 트래픽을 Spring MVC 방식이 처리하지 못했음.
적은 수의 스레드로 대량의 요청을 안정적으로 처리할 수 있는 비동기 Non-Blocking I/O 방식의 Spring WebFlux가 탄생함

#### 15.2 Spring WebFlux의 기술 스택

- 서버 : Servlet 기반 (아파치 톰캣, 서블릿 컨테이서) Blocking I/O - Non-Blocking I/O Netty 등의 서버 엔진
- 서버 API : 서블릿 API - Jetty나 Undertow 같은 리액티브 스트림즈 어댑터
- 보안 : Spring Security - WebFilter
- 데이터 액세스 : JDBC, JPA - R2DBC (Non-Blocking I/O)

#### 15.3 Spring WebFlux의 요청 처리 흐름

HttpHandler ServerWebExchange 생성 (ServerHttpRequest, ServerHttpResponse) WebFilter 전달
-> WebFilter 전처리 후 WebHandler (DispatcherHandler)에 전달
-> DispatcherHandler에서 HandlerMapping List를 Flux의 소스로 전달 받음
-> ServerWebExchange 처리할 핸들러 조회
-> 조회한 핸들러의 호출을 HandlerAdapter에 위임
-> HandlerAdapter는 ServerWebExchange 처리할 핸들러를 호출
-> Controller 또는 HandlerFunction 형태의 핸들러에서 요청을 처리한 후, 응답 데이터를 리턴
-> 핸들러로부터 리턴받은 응답 데이터를 처리할 HandlerResultHandler 조회
-> 조회한 HandlerResultHandler가 응답 데이터 처리 후 response 리턴

#### 15.4 Spring WebFlux의 핵심 컴포넌트

```java
public interface HttpHandler {
    Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response);
}

public class HttpWebHandlerAdapter extends WebHandlerDecorator implements HttpHandler {
    @Override
    public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {
        ServerWebExchange exchange = createExchange(request, response);
    }
}
```

```java
public interface WebFilter {
    Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain);
}
```

Spring WebFlux는 클라이언트의 요청부터 응답까지 Reactor의 두 가지 타입인 Mono나 Flux의 Operator 체인으로 구성된 하나의 길다란 Sequence라고 생각하면 좀 더 쉽게 접근할 수 있다.

```java
@FunctionalInterface
public interface HandlerFilterFunction<T extends ServerResponse, R extends ServerResponse> {
    Mono<R> filter(ServerRequest request, HandlerFunction<T> next);
}
```

DispatcherHandler
initStrategies(ApplicationContext context)
handle(ServerWebExchange exchange)

```java
public interface HandlerMapping {
    Mono<Object> getHandler(ServerWebExchange exchange);
}
```

```java
public interface HandlerAdapter {
    boolean supports(Object handler);
    
    Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler);
}
```

#### 15.5 Spring WebFlux의 Non-Blocking 프로세스 구조
Spring WebFlux가 스레드 차단 없이 더 많은 요청을 처리할 수 있는 이유는 요청 처리 방식으로
이벤트 루프 방식을 사용하기 때문입니다.

#### 15.6 Spring WebFlux의 스레드 모델
클라이언트의 요청이 들어올 때마다 서블릿 컨테이너의 스레드 풀에 미리 생성되어 있는 스레드가 요청을 처리하고 요청 처리를 완료하면
스레드 풀에 반납되는 스레드 모델을 사용

### CHAPTER 16 애너테이션 기반 컨트롤러

#### 16.1 Spring MVC 기반 Controller

#### 16.2 Spring WebFlux 기반 Controller
Mono 타입을 리턴

### CHAPTER 17 함수형 엔드포인트

#### 17.1 HandlerFunction 사용한 request 처리

- ServerRequest
- ServerResponse

#### 17.2 request 라우팅을 위한 RouterFunction

#### 17.3 함수형 엔드포인트에서의 request body 유효성 검증

