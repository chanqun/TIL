코프링 매우 알은 체하기

코틀린이란?
- JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는 정적 타입 지정 언어 (컴파일 시점에 타입이 적용)
- 젯브레인즈에서 개발한 오픈 소스
- OO 스타일과 FP 스타일을 모두 사용 가능
- 간결하고 실용적이며 안전하고 기존 언어와의 상호 운용성 (+코루틴)


자바 릴리즈가 느려서 스칼라가 나왔는데 불편했다 그래서 코틀린 출시


#### 코틀린 표준 라이브러리를 익히고 사용
- 코틀린 1.3 부터 모든 플랫폼에서 사용할 수 있는 kotlin.random.Random이 도입
- 더 이상 Random ThreadLocalRandom을 사용할지 고민할 필요가 없음 (thread safe 고민을 할 필요가 없어짐)
- 자바와 관련된 import문을 제거할 수 있음
- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용 가능


- 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공
- 인터페이스를 만족하는 실제 컬렉션이 반환. 플랫폼별 컬렉션을 사용할 수 있다


#### 코틀린 JVM
```kotlin
class Person(val name: String, val age: Int = 1) {
    var nickname: String? = null
}
```

#### 자바로 역컴퍼일하는 습관을 들여라
- 코틀린 숙련도를 향상시키는 가장 좋은 방법 중 하나는 작성한 코드가 자바로 어떻게 표현되는지 확인
- 역컴파일을 통해 예기치 않은 코드 생성을 방지할 수 있음
- 기존 자바 라이브러리와 프레임워크를 사용하며 문제가 발생할 때 빠르게 확인 가능
- IntelliJ IDEA에서 Tools > Kotlin > Show Kotlin Bytecode => Decompile


#### 롬복 대신 데이터 클래스를 사용하라
- 데이터를 저장하거나 전달하는 것이 주 목적인 클래스를 만드는 경우가 많다. 이러한 클래스의 일부 표준 및 유틸리티 함수는 데이터에서 기계적으로 파생된다.
- 자바에서는 롬복의 @Data를 사용하여 보일러플레이트 코드를 생성
- 애너테이션 프로세서는 코틀린 컴파일 이후에 동작하기 때문에 롬복에서 생성된 자바 코드는 코틀린 코드에서 접근할 수 없다.
- 코틀린 코드보다 자바 코드를 먼저 컴파일하도록 빌드 순서를 조정하면 롬복 문제는 해결할 수 있다.
하지만 자바 코드에서 코틀린 코드를 호출할 수 없게 된다.

> 1.5.20 부터 롬복 컴파일러 플러그인이 실험적으로 추가
> kotlin 도입 과정에서 만난 문제와 해결 방법 d2.naver에 있음

- equals(), hashCode(), toString(), copy() 
- copy()를 적절히 사용하면 데이터 클래스를 불변으로 관리
- 코틀린 1.5부터 자바 16의 레코드 클래스 지원

