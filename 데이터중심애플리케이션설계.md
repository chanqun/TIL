# 데이터 중심 애플리케이션 설계 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 시스템을 지탱하는 핵심 아이디어

1부 데이터 중심 애플리케이션 설계 근본 개념
2부 한 장비에서 여러 장비로 분산 저장
3부 데이터셋에서 데이터셋을 파생하는 시스템

## Part 1. 데이터 시스템의 기초

### 1장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

오늘날 많은 애플리케이션은 계산 중심과는 다르게 데이터 중심적

일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소로 만듬
- 데이터베이스
- 캐시
- 검색 색인
- 스트림 처리 - 비동기 처리를 위해 다른 프로세스로 메시지 보내기
- 일괄처리


#### 신뢰성
무언가 잘못되더라도 지속적을 올바르게 동작함
결함을 예측하고 대응할 수 있는 시스템 (결함성 또는 탄력성 - 넷플릭스 카오스 몽키)
    - 하드웨어 오류
    - 소프트웨어 오류
    - 인적 오류 (오류의 가능성을 최소화하는 인터페이스, 오류용 샌드박스 제공, 테스트하라, 롤백을 빠르게, 모니터링, 교육)

트위터 트윗작성 및 홈 타임라인 - 트위터의 확장성 문제는 주로 트윗 양이 아닌 팬 아웃
1. 트윗 작성은 간단히 새로운 트윗을 트윗 전역에 삽입, 홈 타임라인 요청하는 경우 팔로우하는 모든 사람 찾고, 시간 순으로 정렬
2. 각 수신 사용자용 트윗 우편함처럼 개별 사용자의 홈 타임라인 캐시를 유지 트윗을 작성하면 해당 사용자를 팔로우하는 사람에게 새로운 트윗을 삽입

왜? 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 떄문에
(하지만 팔로워가 3천만 명 넘는 사람은 단일 트윗이 3천만 건 이상의 쓰기 요청이 될 수 있음)

-> 혼합형을 사용한다. 팔로워 수가 많은 사람은 1번 방식 

#### 확장성

성능 기술 - 특이값, 산술평균, 중앙값
부하 대응 접근 방식 - scaling up, scaling out

#### 유지보수성
유지보수성 (운용성, 단순성, 발전성)

### 2장 데이터 모델과 질의 언어

데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영향을 미친다.

#### 관계형 모델과 문서 모델
관계형 데이터베이스의 근원은 비즈니스 데이터 처리 - 트랜잭션 처리와 일괄 처리

#### NoSQL의 탄생
- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 확장성 필요
- 무료 오픈소스 소프트웨어 선호도 확산
- 관계형 모델에서 지원하지 않는 특수 질의
- 동적이고 표현력 풍부한 모델

#### 객체 관계형 불일치
데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터 베이스 모델 객체 사이의 전환 계층이 필요 (임피던스 불일치)

이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 json으로 적합

다대다 처리가 어려울 때 -> 관계형 모델, 네트워크 모델(타고 찾아야함 포인터 같음) 해결법이 있었음

다대일과 다대다 관계를 표현할 떄 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다 (외래 키, 문서 참조)

- 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않음
- 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정되는 경우
이런 경우 스키마는 득보다 실이 많음 

#### 데이터를 위한 질의 언어
sql은 선언형, ims와 코다실은 명령형

#### 맵리듀스 질의
맵리듀스는 선언형 질의와 명령형 질의 중간 정도,

#### 그래프형 데이터 모델
소셜 그래프, 웹 그래프, 도로나 철도 네트워크

#### 속성 그래프
각 정점은
- 고유한 식별자
- 유출 간선 집합
- 유입 간선 집합
- 속성 컬렉션
각 간선은
- 고유한 식별자
- 꼬리 정점
- 머리 정점
- 정점 간 관계 유형 설명하는 레이블
- 속성 컬렉션
을 가짐

#### 사이퍼 질의 언어
속성 그래프를 위한 선언형 질의 언어

#### 트리플 저장소와 스파클, 시맨틱 웹, RDF 데이터 모델, 스파클 질의 언어,

### 3장 저장소와 검색

가장 기본적인 수준에서 데이터베이스는 두 가지 작업을 수행한다. 어떤 데이터를 받으면 데이터를 저장하고 나중에 그 데이터를 요청하면 다시 데이터를 제공한다.

애플리케이션 개발자가 주의해야 하는 이유는 특정장업부하 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하기 위해서이다.
(로그 구조(log-structured) 계열 저장소 엔진과 페이지 지향 계열 저장소 엔진을 검토)

색인을 잘 선택했다면 읽기 질의 속도가 향상된다. 하지만 모든 색인은 쓰기 속도를 떨어뜨린다. (저장소 시스템에서 중요한 트레이드오프)

#### 해시 색인
키-값 사전 타입과 매우 유사
세그먼트 나누고 컴팩션 잘해야함

실제 구현에서 중요한 문제
- 파일 형식, 레코드 삭제, 고장 복구, 부분적으로 레코드 쓰기, 동시성 제어
  (키가 너무 많으면 문제가 된다, 해쉬 테이블은 범위 질의에 효율적이지 않다)

##### SS 테이블과 LSM 트리
##### B트리와 LSM 트리

#### 트랜잭션 처리나 분석
OLTP (online transaction processing), OLAP(online analytic processing)

데이터 웨어하우스는 분석가들이 OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스다.

#### 분석용 스키마 : 별 모양 스키마와 눈꽃송이 모양 스키마
별 모양 스키마란 이름은 테이 이름은 테이블 관계가 시각화될 떄 사실 테이블이 가운데에 있고 차원 테이블로 둘러싸고 있다는 사실에서 비롯됐다.
눈꽃송이 모양 스키마라고 하며 차원이 하위차원으로 더 세분화된다.

#### 칼럽 지향 저장소
칼럼 지향 저장소의 기본 개념은 모든 값을 하나의 로우에 하몎 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저
#### 칼럼 압축
비트맵 부호화, 메모리 대역폭과 벡터화 처리, 
#### 칼럼 저장소의 순서 정렬, 다양한 순서 정렬
#### 칼럼 지향 저장소에 쓰기

- OLTP 시스템은 보통 사용자 대면이기 때문에 대량의 요청을 받을 수 있다. 부하를 처리하기 위해 보통 애플리케이션이 각 질의마다 작은 수의 레코드만 다룬다.
애플리케이션은 키의 일부만 사용하는 레코드를 요청하고 저장소 엔진은 요청한 키의 데이터를 찾기 위해 색인을 사용한다. 이 경우는 대개 디스크 탐색이 병목이다.
- 데이터 웨어하우스와 유사한 분석 시스템은 최종 사용자가 아닌 비즈니스 분석가가 주로 사용하기 떄문에 덜 알려져 있다. OLTP 시스템보다 훨씬 더 적은 수의 질의를 다루지만 
각 질의는 대개 매우 다루기 어렵고 짧은 시간에 수백만 개의 레코드를 스캔해야 한다. 이 경우는 일반적으로 디스크 대역폭이 병목이다.
칼럼 지향 저장소는 이런 종류의 작업부하를 처리할 떄 사용 가능한 날로 인기가 높아지고 있는 솔루션이다.

OLTP 측면에서 두 가지 관점
- 로그 구조화 관점에서 파일에 추가와 오래된 파일의 삭제만 허용하고 한 번 쓰여진 파일은 절대 갱신하지 않는다. 비트캐스크, SS테이블, LSM트리, 레벨DB, 카산드라 HBase, 루씬 등이 속함
- 제자리 갱신 관점에서 덮어쓰기 할 수 있는 고정 크기 페이지의 셋으로 디스크를 다룬다. 이 관점에서 가장 큰 예가 B트리다. B 트리는 모든 주요 관계형 데이터베이스와 많은 비정형 데이터베이스에서도 사용한다.

---

io와 index 싸움이다.
aws 돈 많이 받는 것 iops

블록체인에서는 레벨 디비

디스크 io 보다 네트워크 트랜스퍼가 빠름

### 4장 부호화와 발전
- 프로그래밍 언어에 특화된 부호화는 단일 프로그래밍 언어로 제한되며 상위 호환성과 하위 호환성을 제공하지 못하는 경우가 종종 있다.
- JSON, XML, CSV 같은 텍스트 형식은 널리 사용됨
- 스리프트, 프로토콜 버퍼, 아브로 같은 이진 스키마 기반 형식은 짧은 길이로 부호화되며 명확하게 정의된 상위 호환성과 하위 호환성의 맥락에서 효율적인 부호화를 지원한다.
이러한 스키마는 정적 타입 언어에서 문서와 코드 생성에 유용하지만 사람이 읽기 위해서는 복호화해야 한다는 단점이 있다.

- 데이터베이스에 기록하는 프로세스가 부호화하고 데이터베이스에서 읽는 프로세스가 복호화하는 데이터베이스
- 클라이언트가 요청을 부호화하고 서버는 요청을 복호화하고 응답을 부호화하고 최종적으로 클라이언트가 응답을 복호화하는 RPC와 REST API
- 송신자가 부호화하고 수신자가 복호화하는 메시지를 서로 전송해서 노드 간 통신하는 비동기 메시지 전달(메시지 브로커나 액터를 이용)


## part 2 분산 데이터

여러 장비 간 분산된 데이터베이스를 필요로 하는 이유는 여러 가지
- 확장성
- 내결함성/고가용성 -> 장비 하나가 죽어도 애플리케이션이 계속 동작
- 지연 시간 -> 전 세계 다양한 곳에 서버를 둔다.

복제 대 파티셔닝

### 5장 복제
복제가 필요한 이유
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다.
많은 애플리케이션 개발자에게는 이 분야가 새롭기 때문에 최종적 일관성과 같은 문제에 대한 오해가 많음.

#### 리더와 팔로워
리더 기반 복제는 데이터베이스에만 국한되지 않으며 카프카와 래빗MQ의 고가용성 큐 같은 문산 메시지 브로커에도 사용된다.

#### 동기식 대 비동기식 복제
동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다. 단점은 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다
보통 리더 기반 복제는 완전히 비동기식으로 구성 - 복제 지연 문제 추후에 정리

#### 새로운 팔로워 설정
1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다. 대부분의 데이터베이스는 백업이 필요하기 떄문에 이 기능을 갖췄따.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청. 이것은 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다.
postSQL 에서는 로그 일렬번호 mySQL 에서는 이진로그 좌표라 부른다.
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을 때 따라잡았다고 말한다.
#### 노드 중단 처리
리더 기반 복제에서 고가용성은 어떻게 달성할 수 있을까?

팔로워 장애: 따라잡기 복구
리더 장애: 장애 복구

#### 복제 로그 구현
- 구문 기반 복제
- 쓰기 전 로그 배송
- 논리적 로그 복제
- 트리거 기반 복제

#### 복제 지연 문제

애플리케이션 개발자가 미묘한 복제 문제를 걱정하지 않고 올바른 작업 수행을 위해 항상 데이터베이스를 신뢰할 수 있으면 좋다.
이것이 트랜잭션이 있는 이유다.

#### 다중 리더 복제
클라이언트는 각 쓰기를 여러 리더 노드 중 쓰기를 받아들일 수 있는 노드로 전송한다. 리더는 데이터 변경 이벤트 스트림을 다른 리더와 모든 팔로워 노드로 전송하낟.

#### 리더 없는 복제
클라이언트는 각 쓰기를 여러 노드로 전송한다. 클라이언트는 오래된 데이터를 감지하고 이를 바로잡기 위해 병렬로 여러 노드에서 읽는다.

- 쓰기 후 읽기 일관성
- 단조 읽기
- 일관된 순서로 읽기

다중 리더 복제와 리더 없는 복제 접근 방식에 내재된 동시성 문제
(순서를 위한 알고리즘이 있음)

다음 예전 뉴스관련해서 디비 replication이 늦어서 10000 -> 9000 됐다고 여론 조작이다라는 이야기가 있었음

happens before

### 6장 파티셔닝
데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이 작업을 샤딩이라고 한다.
데이터 파티셔닝을 원하는 주된 이유는 확장성 - 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다.

#### 파티셔닝과 복제
- 키-값 데이터 파티셔닝
불균형하게 데이터가 많은 곳을 핫스팟이라고함
- 해시값 기준 파티셔닝 (일관된 해싱)
파티셔닝과 보조 색인

#### 파티션 재균형화
클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화라고 한다.

- 부하가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야한다.
- 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야한다.
- 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안 된다.

#### 재균형화 전략
동적 파티셔닝, 노드 비례 파티셔닝

#### 요청 라우팅


### 7장 트랜잭션

어떤 저자들은 2단계 커밋에서 유발되는 성능이나 가용성 문제 때문에 생기는 비용이 너무 커서 이를 지원할 수 없다고 주장했다.
우리는 항상 트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성늠 문제를 애플리케이션 프로그래머가 처리하게 하는게 낫다고 생각한다.

데이터 시스템은 여러 가지 문제가 생길 수 있다.
- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.
- 애플리케이션은 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

내결함성을 갖춘 시스템을 구현하려면 할 일이 많다. 잘못될 수 있는 모든 것에대해 신중하게 생각해야 하며 테스트를 여러 번 해서 해결책이 실제로 동작하는지 확인해야한다.

트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.

커밋, 어보트

동시성 제어 : 커밋 후 읽기, 스냅숏 격리, 직렬성

#### ACID
atomic, consistency, isolation, durability

더티 읽기
한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 읽는다. 커밋 후 읽기 또는 그보다 강한 격리 수준은 더티 읽기를 방지한다.

더티 쓰기
한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티 쓰기를 방지한다.

읽기 스큐(비반복 일기)
클라이언트는 다른 시점에 데이터베이스의 다른 부분을 본다. 이 문제를 막기 위한 해결책으로 트랜잭션이 어느 시점의 일관된 스냅숏으로부터 읽는 스냅숏 격리를 가장 흔히 사용한다.
스냅숏 격리는 보통 다중 버전 동시성 제어(MVVC)를 써서 구현한다.

갱신 손실
두 클라이언트가 동시에 read-modify-write 주기를 실행한다. 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터가 손실된다.
스냅숏 격리 구현 중 어떤 것은 이런 이상 현상을 자동으로 막아주지만 그렇지 않은 것은 수동 잠금이 필요하다.

쓰기 스큐
트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 쓴다. 그러나 쓰기를 실행하는 시점에는 결정의 전제가 더 이상 참이 아니다.
직렬성 격리만 이런 이상 현상을 막을 수 있다.

팬텀 읽기
트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행한다. 스냅숏 격리는 간단한 팬텀 읽기는 막아주지만 쓰기 스큐 맥락에서
발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요하다.


직렬성 트랜잭션을 구현하는 세 가지 방법
- 트랜잭션을 순서대로 실행
- 2단계 잠금
- 직렬성 스냅숏 격리 (트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않다면 어보트)


### 8장 분산 시스템의 골칫거리

#### 결함과 부분 장애
분산 시스템에서는 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것도 무리가 아니다. 이를 부분 장애라고 한다.

#### 클라우드 컴퓨팅과 슈퍼컴퓨팅
분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다. 바꿔 말하면 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다.

#### 신뢰성 없는 네트워크
인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크다.
1. 요청이 손실됐을 수 있다.
2. 요청이 큐에서 대기하다 나중에 전송될 수 있다.
3. 원격 노드에 장애가 생겼을 수 있다.
4. 원격 노드가 일시적으로 응답하기를 멈췄지만 나중에는 다시 응답하기 시작할 수 있다.
5. 원격 노드가 요청을 처리했지만 응답이 네트워크에서 손실됐을 수 있다.
6. 원격 노드가 요청을 처리했지만 응답이 지연되다가 나중에 전송될 수 있다.
-> 타임아웃으로 주로 처리 

#### 결함 감지
- 로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.

#### 타임아웃과 기약 없는 지연
2d(전송시간)+r(시간 내 처리 보장 시간) 

#### 시계 읽기는 신뢰 구간이 있다.

#### 정리
- 네트워크로 패킷을 보내려고 할 때는 언제나 패킷이 손실되거나 임의대로 지연될 수 있다, 마찬가지로 응답도 손실되거나 지연될 수 있으므로 응답을 받지 못하면 메시지가 전달됐는지 아닌지를 알 수 없다.
- 노드의 시계는 다른 노드와 심하게 맞지 않을 수 있고 시간이 갑자기 앞뒤로 뛸 수도 있따. 그리고 시계의 오차 구간을 측정할 좋은 수단이 없을 가능성이 크므로 시계에 의존하는 것은 위험하다.
- 프로세스는 실행 도중 어느 시점에서 상당한 시간 동안 멈출 수 있고 다른 노드에 의해 죽었따고 선언될 수 있으며 되살아났을 때 멈췄다는 사실을 알지 못할 수 있다.

### 9장

